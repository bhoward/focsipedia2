"use strict";(self.webpackChunkfocsipedia=self.webpackChunkfocsipedia||[]).push([["2652"],{28524:function(e,s,n){n.r(s),n.d(s,{default:()=>d,frontMatter:()=>i,metadata:()=>a,assets:()=>l,toc:()=>m,contentTitle:()=>c});var a=JSON.parse('{"id":"fp/parser-comb","title":"Recursive Descent and Parser Combinators","description":"It is particularly easy to turn an LL(1) grammar into an efficient parser","source":"@site/focsipedia-docs/target/mdoc/fp/parser-comb.md","sourceDirName":"fp","slug":"/fp/parser-comb","permalink":"/focsipedia2/docs/fp/parser-comb","draft":false,"unlisted":false,"editUrl":"https://github.com/bhoward/focsipedia2/edit/main/docs/fp/parser-comb.md","tags":[],"version":"current","frontMatter":{"id":"parser-comb","title":"Recursive Descent and Parser Combinators"},"sidebar":"mySidebar","previous":{"title":"State Machines in Java and ReasonML","permalink":"/focsipedia2/docs/fp/state"},"next":{"title":"Lambda Calculus","permalink":"/focsipedia2/docs/fp/lambda"}}'),t=n("85893"),r=n("50065");let i={id:"parser-comb",title:"Recursive Descent and Parser Combinators"},c=void 0,l={},m=[{value:"Parser Combinators",id:"parser-combinators",level:2}];function p(e){let s={a:"a",annotation:"annotation",code:"code",h2:"h2",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",mstyle:"mstyle",msub:"msub",mtable:"mtable",mtd:"mtd",mtext:"mtext",mtr:"mtr",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(s.p,{children:["It is particularly easy to turn an LL(1) grammar into an efficient parser\nusing the technique of ",(0,t.jsx)(s.strong,{children:"recursive descent parsing"}),". For each non-terminal in\nthe grammar, we write a function that recognizes strings produced from that\nnon-terminal. If there are multiple productions for the non-terminal, we use\nthe next available character to decide which one to use. To parse the right-hand\nside of the chosen production rule, we have to recognize a sequence of terminals\nand non-terminals in order. To recognize a terminal, we just check that the current\ncharacter from the input matches the expected symbol. To recognize a non-terminal,\nwe call the associated function for that non-terminal."]}),"\n",(0,t.jsxs)(s.p,{children:["Therefore, our parser will be a set of mutually recursive functions, one for each\nnon-terminal. To parse a word in the language, we call the function corresponding\nto the starting non-terminal; if that function returns without error, then we have\nsuccessfully matched a word. In addition to recognizing a string of characters, it\nis common for each recursive descent parsing function to return a data structure\n(the parse tree, or a close relative known as an ",(0,t.jsx)(s.strong,{children:"abstract syntax tree"}),") representing\nthe input that was parsed."]}),"\n",(0,t.jsxs)(s.p,{children:["Here is code for a recursive descent parser in Java, corresponding to the following\ngrammar (expressed here in ",(0,t.jsx)(s.a,{href:"/focsipedia2/docs/lang/bnf",children:"Backus-Naur form"}),"; it is very similar\nto the example ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsx)(s.mrow,{children:(0,t.jsxs)(s.msub,{children:[(0,t.jsx)(s.mi,{children:"G"}),(0,t.jsx)(s.mn,{children:"2"})]})}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"G_2"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,t.jsxs)(s.span,{className:"mord",children:[(0,t.jsx)(s.span,{className:"mord mathnormal",children:"G"}),(0,t.jsx)(s.span,{className:"msupsub",children:(0,t.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,t.jsxs)(s.span,{className:"vlist-r",children:[(0,t.jsx)(s.span,{className:"vlist",style:{height:"0.3011em"},children:(0,t.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[(0,t.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,t.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,t.jsx)(s.span,{className:"mord mtight",children:"2"})})]})}),(0,t.jsx)(s.span,{className:"vlist-s",children:"\u200B"})]}),(0,t.jsx)(s.span,{className:"vlist-r",children:(0,t.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,t.jsx)(s.span,{})})})]})})]})]})})]})," discussed in the ",(0,t.jsx)(s.a,{href:"/focsipedia2/docs/lang/parsing",children:"parsing"})," section):"]}),"\n",(0,t.jsx)(s.span,{className:"katex-display",children:(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mtable,{rowspacing:"0.25em",columnalign:"right left",columnspacing:"0em",children:[(0,t.jsxs)(s.mtr,{children:[(0,t.jsx)(s.mtd,{children:(0,t.jsx)(s.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E8"}),(0,t.jsx)(s.mtext,{mathvariant:"italic",children:"Expr"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E9"}),(0,t.jsx)(s.mtext,{children:"\xa0"})]})})}),(0,t.jsx)(s.mtd,{children:(0,t.jsx)(s.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mrow,{}),(0,t.jsx)(s.mo,{children:":"}),(0,t.jsx)(s.mo,{children:":"}),(0,t.jsx)(s.mo,{children:"="}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E8"}),(0,t.jsx)(s.mtext,{mathvariant:"italic",children:"Term"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E9"}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"["}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mo,{children:"+"}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mi,{mathvariant:"normal",children:"\u2223"}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mo,{children:"\u2212"}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E8"}),(0,t.jsx)(s.mtext,{mathvariant:"italic",children:"Term"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E9"}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"]"}),(0,t.jsx)(s.mo,{children:"\u2026"})]})})})]}),(0,t.jsxs)(s.mtr,{children:[(0,t.jsx)(s.mtd,{children:(0,t.jsx)(s.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E8"}),(0,t.jsx)(s.mtext,{mathvariant:"italic",children:"Term"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E9"}),(0,t.jsx)(s.mtext,{children:"\xa0"})]})})}),(0,t.jsx)(s.mtd,{children:(0,t.jsx)(s.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mrow,{}),(0,t.jsx)(s.mo,{children:":"}),(0,t.jsx)(s.mo,{children:":"}),(0,t.jsx)(s.mo,{children:"="}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E8"}),(0,t.jsx)(s.mtext,{mathvariant:"italic",children:"Factor"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E9"}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"["}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mo,{children:"\u2217"}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mi,{mathvariant:"normal",children:"\u2223"}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mi,{mathvariant:"normal",children:"/"}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E8"}),(0,t.jsx)(s.mtext,{mathvariant:"italic",children:"Factor"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E9"}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"]"}),(0,t.jsx)(s.mo,{children:"\u2026"})]})})})]}),(0,t.jsxs)(s.mtr,{children:[(0,t.jsx)(s.mtd,{children:(0,t.jsx)(s.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E8"}),(0,t.jsx)(s.mtext,{mathvariant:"italic",children:"Factor"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E9"}),(0,t.jsx)(s.mtext,{children:"\xa0"})]})})}),(0,t.jsx)(s.mtd,{children:(0,t.jsx)(s.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mrow,{}),(0,t.jsx)(s.mo,{children:":"}),(0,t.jsx)(s.mo,{children:":"}),(0,t.jsx)(s.mo,{children:"="}),(0,t.jsx)(s.mtext,{children:"\xa0ident\xa0"}),(0,t.jsx)(s.mi,{mathvariant:"normal",children:"\u2223"}),(0,t.jsx)(s.mtext,{children:"\xa0num\xa0"}),(0,t.jsx)(s.mi,{mathvariant:"normal",children:"\u2223"}),(0,t.jsx)(s.mtext,{children:"\xa0\u201C(\u201D\xa0"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E8"}),(0,t.jsx)(s.mtext,{mathvariant:"italic",children:"Expr"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"\u27E9"}),(0,t.jsx)(s.mtext,{children:"\xa0\u201C)\u201D"})]})})})]})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\begin{aligned}\n\\langle\\textit{Expr}\\rangle\\ &::=\\ \\langle\\textit{Term}\\rangle\\ [\\ (\\ +\\ |\\ -\\ )\\ \\langle\\textit{Term}\\rangle\\ ]\\ldots\\\\\n\\langle\\textit{Term}\\rangle\\ &::=\\ \\langle\\textit{Factor}\\rangle\\ [\\ (\\ *\\ |\\ /\\ )\\ \\langle\\textit{Factor}\\rangle\\ ]\\ldots\\\\\n\\langle\\textit{Factor}\\rangle\\ &::=\\ \\textrm{ident}\\ |\\ \\textrm{num}\\ |\\ \\textrm{``(''}\\ \\langle\\textit{Expr}\\rangle\\ \\textrm{``)''}\n\\end{aligned}"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"4.5em",verticalAlign:"-2em"}}),(0,t.jsx)(s.span,{className:"mord",children:(0,t.jsxs)(s.span,{className:"mtable",children:[(0,t.jsx)(s.span,{className:"col-align-r",children:(0,t.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,t.jsxs)(s.span,{className:"vlist-r",children:[(0,t.jsxs)(s.span,{className:"vlist",style:{height:"2.5em"},children:[(0,t.jsxs)(s.span,{style:{top:"-4.66em"},children:[(0,t.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsxs)(s.span,{className:"mord",children:[(0,t.jsx)(s.span,{className:"mopen",children:"\u27E8"}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord textit",children:"Expr"})}),(0,t.jsx)(s.span,{className:"mclose",children:"\u27E9"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"})]})]}),(0,t.jsxs)(s.span,{style:{top:"-3.16em"},children:[(0,t.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsxs)(s.span,{className:"mord",children:[(0,t.jsx)(s.span,{className:"mopen",children:"\u27E8"}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord textit",children:"Term"})}),(0,t.jsx)(s.span,{className:"mclose",children:"\u27E9"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"})]})]}),(0,t.jsxs)(s.span,{style:{top:"-1.66em"},children:[(0,t.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsxs)(s.span,{className:"mord",children:[(0,t.jsx)(s.span,{className:"mopen",children:"\u27E8"}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord textit",children:"Factor"})}),(0,t.jsx)(s.span,{className:"mclose",children:"\u27E9"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"})]})]})]}),(0,t.jsx)(s.span,{className:"vlist-s",children:"\u200B"})]}),(0,t.jsx)(s.span,{className:"vlist-r",children:(0,t.jsx)(s.span,{className:"vlist",style:{height:"2em"},children:(0,t.jsx)(s.span,{})})})]})}),(0,t.jsx)(s.span,{className:"col-align-l",children:(0,t.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,t.jsxs)(s.span,{className:"vlist-r",children:[(0,t.jsxs)(s.span,{className:"vlist",style:{height:"2.5em"},children:[(0,t.jsxs)(s.span,{style:{top:"-4.66em"},children:[(0,t.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsxs)(s.span,{className:"mord",children:[(0,t.jsx)(s.span,{className:"mord"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(s.span,{className:"mrel",children:"::="}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(s.span,{className:"mopen",children:"\u27E8"}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord textit",children:"Term"})}),(0,t.jsx)(s.span,{className:"mclose",children:"\u27E9"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mopen",children:"["}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mord",children:"+"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mord",children:"\u2223"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mord",children:"\u2212"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mclose",children:")"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mopen",children:"\u27E8"}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord textit",children:"Term"})}),(0,t.jsx)(s.span,{className:"mclose",children:"\u27E9"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mclose",children:"]"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"minner",children:"\u2026"})]})]}),(0,t.jsxs)(s.span,{style:{top:"-3.16em"},children:[(0,t.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsxs)(s.span,{className:"mord",children:[(0,t.jsx)(s.span,{className:"mord"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(s.span,{className:"mrel",children:"::="}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(s.span,{className:"mopen",children:"\u27E8"}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord textit",children:"Factor"})}),(0,t.jsx)(s.span,{className:"mclose",children:"\u27E9"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mopen",children:"["}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mord",children:"\u2217"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mord",children:"\u2223"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mord",children:"/"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mclose",children:")"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mopen",children:"\u27E8"}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord textit",children:"Factor"})}),(0,t.jsx)(s.span,{className:"mclose",children:"\u27E9"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mclose",children:"]"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"minner",children:"\u2026"})]})]}),(0,t.jsxs)(s.span,{style:{top:"-1.66em"},children:[(0,t.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsxs)(s.span,{className:"mord",children:[(0,t.jsx)(s.span,{className:"mord"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(s.span,{className:"mrel",children:"::="}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord textrm",children:"ident"})}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mord",children:"\u2223"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord textrm",children:"num"})}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mord",children:"\u2223"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord textrm",children:"\u201C(\u201D"})}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mopen",children:"\u27E8"}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord textit",children:"Expr"})}),(0,t.jsx)(s.span,{className:"mclose",children:"\u27E9"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord textrm",children:"\u201C)\u201D"})})]})]})]}),(0,t.jsx)(s.span,{className:"vlist-s",children:"\u200B"})]}),(0,t.jsx)(s.span,{className:"vlist-r",children:(0,t.jsx)(s.span,{className:"vlist",style:{height:"2em"},children:(0,t.jsx)(s.span,{})})})]})})]})})]})})]})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-java",children:"/**\n * Represents an expression node in an abstract syntax tree.\n */\npublic interface Expr {\n	// instance methods appropriate to the application should be declared here\n\n	/**\n	 * Parse an expression (sum/difference of one or more terms).\n	 * \n	 * @param input\n	 * @return\n	 */\n	public static Expr parse(Input input) {\n		Expr e = parseTerm(input);\n		while (input.peek() == '+' || input.peek() == '-') {\n			BinOp op = BinOp.parse(input);\n			Expr e2 = Expr.parseTerm(input);\n			e = new BinOpExpr(e, op, e2);\n		}\n		return e;\n	}\n\n	/**\n	 * Parse a term (product/quotient of one or more factors).\n	 * \n	 * @param input\n	 * @return\n	 */\n	public static Expr parseTerm(Input input) {\n		Expr e = parseFactor(input);\n		while (input.peek() == '*' || input.peek() == '/') {\n			BinOp op = BinOp.parse(input);\n			Expr e2 = Expr.parseFactor(input);\n			e = new BinOpExpr(e, op, e2);\n		}\n		return e;\n	}\n\n	/**\n	 * Parse a factor (identifier, number, or parenthesized expression). Throws a\n	 * RuntimeException if a factor is not available.\n	 * \n	 * @param input\n	 * @return\n	 */\n	public static Expr parseFactor(Input input) {\n		if (Character.isLetter(input.peek())) {\n			String id = input.readIdent();\n			return new IdentExpr(id);\n		} else if (Character.isDigit(input.peek())) {\n			int n = input.readInt();\n			return new NumExpr(n);\n		} else if (input.peek() == '(') {\n			input.skip();\n			Expr e = parse(input);\n			input.match(')');\n			return e;\n		} else {\n			throw new RuntimeException(\"expected a factor\");\n		}\n	}\n}\n\npublic class BinOpExpr implements Expr {\n	private Expr left, right;\n	private BinOp op;\n\n	public BinOpExpr(Expr left, BinOp op, Expr right) {\n		this.left = left;\n		this.op = op;\n		this.right = right;\n	}\n\n	public String toString() {\n		return \"BinOp(\" + left + \", \" + op + \", \" + right + \")\";\n	}\n}\n\npublic class IdentExpr implements Expr {\n	private String id;\n\n	public IdentExpr(String id) {\n		this.id = id;\n	}\n\n	public String toString() {\n		return \"Ident(\" + id + \")\";\n	}\n}\n\npublic class NumExpr implements Expr {\n	private int n;\n\n	public NumExpr(int n) {\n		this.n = n;\n	}\n\n	public String toString() {\n		return \"Num(\" + n + \")\";\n	}\n}\n\n/**\n * Represents the binary operators available in the abstract syntax for\n * expressions.\n */\npublic enum BinOp {\n	PLUS, MINUS, TIMES, DIVIDE;\n\n	/**\n	 * Parse a binary operator from the given Input. Should only be called when the\n	 * current character may start an operator.\n	 * \n	 * @param input\n	 * @return\n	 */\n	static BinOp parse(Input input) {\n		switch (input.peek()) {\n		case '+':\n			input.skip();\n			return PLUS;\n		case '-':\n			input.skip();\n			return MINUS;\n		case '*':\n			input.skip();\n			return TIMES;\n		case '/':\n			input.skip();\n			return DIVIDE;\n		default:\n			return null; // shouldn't happen\n		}\n	}\n}\n\n/**\n * Wrapper around a Reader that provides useful abstractions for recursive\n * descent parsing.\n */\npublic class Input {\n	private java.io.Reader source;\n	private char next;\n	private boolean atEnd;\n\n	public Input(java.io.Reader source) {\n		this.source = source;\n		skip();\n	}\n\n	/**\n	 * @return current available character\n	 */\n	public char peek() {\n		return next;\n	}\n\n	/**\n	 * @return true if no more characters available\n	 */\n	public boolean atEnd() {\n		return atEnd;\n	}\n\n	/**\n	 * Read the next available character, skipping over whitespace\n	 */\n	public void skip() {\n		readNext();\n		skipWhitespace();\n	}\n\n	/**\n	 * If the current character is c, skip to the next. Throw a RuntimeException if\n	 * the character does not match.\n	 * \n	 * @param c\n	 */\n	public void match(char c) {\n		if (next == c) {\n			skip();\n		} else {\n			throw new RuntimeException(\"expected \" + c + \" but found \" + next);\n		}\n	}\n\n	/**\n	 * Read an identifier (letter followed by zero or more letters or digits). This\n	 * should only be called when the current character is a letter.\n	 * \n	 * @return the identifier\n	 */\n	public String readIdent() {\n		StringBuilder builder = new StringBuilder();\n		builder.append(next);\n		readNext();\n		while (!atEnd && Character.isLetterOrDigit(next)) {\n			builder.append(next);\n			readNext();\n		}\n		skipWhitespace();\n		return builder.toString();\n	}\n\n	/**\n	 * Read an integer (digit followed by zero or more additional digits). This\n	 * should only be called when the current character is a digit.\n	 * \n	 * @return the number\n	 */\n	public int readInt() {\n		int result = next - '0';\n		readNext();\n		while (!atEnd && Character.isDigit(next)) {\n			result = result * 10 + next - '0';\n			readNext();\n		}\n		skipWhitespace();\n		return result;\n	}\n\n	private void readNext() {\n		try {\n			int c = source.read();\n			if (c != -1) {\n				next = (char) c;\n				atEnd = false;\n			} else {\n				next = '\\0';\n				atEnd = true;\n			}\n		} catch (java.io.IOException e) {\n			next = '\\0';\n			atEnd = true;\n		}\n	}\n\n	private void skipWhitespace() {\n		while (!atEnd && Character.isWhitespace(next)) {\n			readNext();\n		}\n	}\n}\n\npublic class Demo {\n	public static void main(String[] args) {\n		String sample = \"  3*abc + (x1 - x0) * r2d2/42 \\n\";\n		Input input = new Input(new StringReader(sample));\n		Expr e = Expr.parse(input);\n		if (input.atEnd()) {\n			System.out.println(\"Found \" + e);\n		} else {\n			System.out.println(\"unscanned input after parsing \" + e);\n		}\n	}\n}\n"})}),"\n",(0,t.jsx)(s.h2,{id:"parser-combinators",children:"Parser Combinators"}),"\n",(0,t.jsxs)(s.p,{children:["Instead of giving a direct translation of the Java version into Scala, it is\ncommon in functional languages to use what are known as ",(0,t.jsx)(s.strong,{children:"parser combinators"}),'\nto write recursive descent parsers. A parser is viewed as a function from input\nto the pair of a result plus the remaining input (since in a functional language\nwe do not want to use side-effects to update the "current character" available from\nan input source). A parser combinator is then a function that can combine one or\nmore of these parsing functions into a composite parser.']}),"\n",(0,t.jsxs)(s.p,{children:["The example below uses the\n",(0,t.jsx)(s.a,{href:"https://com-lihaoyi.github.io/fastparse/",children:"FastParse combinator parsing library"}),".\nFor example, given parsers ",(0,t.jsx)(s.code,{children:"p1"})," and ",(0,t.jsx)(s.code,{children:"p2"}),", the combinator ",(0,t.jsx)(s.code,{children:"|"})," produces the parser\n",(0,t.jsx)(s.code,{children:"p1 | p2"})," which attempts to parse according to ",(0,t.jsx)(s.code,{children:"p1"}),"; if it fails, then it attempts\nto use ",(0,t.jsx)(s.code,{children:"p2"})," instead. This corresponds to the ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsx)(s.mrow,{children:(0,t.jsx)(s.mi,{mathvariant:"normal",children:"\u2223"})}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"|"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord",children:"\u2223"})]})})]})," (choice) operator in BNF (and also\nin regular expressions). Some of the other combinators used below are ",(0,t.jsx)(s.code,{children:"~"}),", which\ncorresponds to sequencing one parser after another, and ",(0,t.jsx)(s.code,{children:"rep"}),", which repeats a\nparser zero or more times (like the Kleene star).\nThe ",(0,t.jsx)(s.code,{children:"map"})," operations take the result of parsing a particular rule and construct the\ndesired abstract syntax tree of type ",(0,t.jsx)(s.code,{children:"Expr"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["Here is the parser for arithmetic expressions, corresponding to the Java example above.\nNote how the definitions of ",(0,t.jsx)(s.code,{children:"expr"}),", ",(0,t.jsx)(s.code,{children:"term"}),", and ",(0,t.jsx)(s.code,{children:"factor"})," are very close to the original BNF:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-scala",children:'package test\n\nenum Expr:\n  case Ident(name: String)\n  case Num(value: Int)\n  case BinOp(left: Expr, op: String, right: Expr)\nimport Expr.*\n\nimport fastparse._, SingleLineWhitespace._\n\nobject ExprParse:\n  def apply(input: String): Either[String, Expr] = {\n    parse(input, { case given P[_] => top }) match\n    case Parsed.Success(value, _) => Right(value)\n    case result: Parsed.Failure => Left(result.msg)\n  }\n    \n  def top[$: P]: P[Expr] = P ( Start ~ expr ~ End )\n\n  def expr[$: P]: P[Expr] = P( term ~ (addOp ~ term).rep )\n    .map { case (t, rest) => rest.foldLeft(t) { case (e1, (op, e2)) => BinOp(e1, op, e2) }}\n\n  def term[$: P]: P[Expr] = P( factor ~ (mulOp ~ factor).rep )\n    .map { case (f, rest) => rest.foldLeft(f) { case (e1, (op, e2)) => BinOp(e1, op, e2) }}\n\n  def factor[$: P]: P[Expr] = P( id | num | "(" ~ expr ~ ")" )\n\n  def id[$: P]: P[Expr] = P( ident.map(Ident(_)) )\n\n  def num[$: P]: P[Expr] = P( number.map(n => Num(n.toInt)) )\n\n  // Lexical Syntax\n  def ident[$: P] = P( CharIn("A-Za-z").! ~~ CharsWhileIn("A-Za-z0-9").?.! )\n    .map { case (init, rest) => init + rest }\n\n  def number[$: P] = P( ("-".? ~~ CharsWhileIn("0-9")).! )\n\n  def addOp[$: P] = P( ("+" | "-").! )\n\n  def mulOp[$: P] = P( ("*" | "/").! )\n\n  @main def demo(): Unit = {\n    val input = "a*x*x + b*x + c"\n\n    ExprParse(input) match\n        case Right(expr) =>\n          println(expr)\n        case Left(message) =>\n          println("Error: " + message)\n  }\n'})})]})}function d(e={}){let{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},50065:function(e,s,n){n.d(s,{Z:function(){return c},a:function(){return i}});var a=n(67294);let t={},r=a.createContext(t);function i(e){let s=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),a.createElement(r.Provider,{value:s},e.children)}}}]);