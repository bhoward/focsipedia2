"use strict";(self.webpackChunkfocsipedia=self.webpackChunkfocsipedia||[]).push([[4102],{55180:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>i,metadata:()=>n,toc:()=>m});const n=JSON.parse('{"id":"fp/parser-comb","title":"Recursive Descent and Parser Combinators","description":"It is particularly easy to turn an LL(1) grammar into an efficient parser","source":"@site/focsipedia-docs/target/mdoc/fp/parser-comb.md","sourceDirName":"fp","slug":"/fp/parser-comb","permalink":"/focsipedia2/docs/fp/parser-comb","draft":false,"unlisted":false,"editUrl":"https://github.com/bhoward/focsipedia2/edit/main/docs/fp/parser-comb.md","tags":[],"version":"current","frontMatter":{"id":"parser-comb","title":"Recursive Descent and Parser Combinators"},"sidebar":"mySidebar","previous":{"title":"State Machines in Java and ReasonML","permalink":"/focsipedia2/docs/fp/state"},"next":{"title":"Lambda Calculus","permalink":"/focsipedia2/docs/fp/lambda"}}');var a=s(74848),r=s(28453);const i={id:"parser-comb",title:"Recursive Descent and Parser Combinators"},c=void 0,l={},m=[{value:"Parser Combinators",id:"parser-combinators",level:2}];function p(e){const t={a:"a",annotation:"annotation",code:"code",h2:"h2",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",mstyle:"mstyle",msub:"msub",mtable:"mtable",mtd:"mtd",mtext:"mtext",mtr:"mtr",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["It is particularly easy to turn an LL(1) grammar into an efficient parser\nusing the technique of ",(0,a.jsx)(t.strong,{children:"recursive descent parsing"}),". For each non-terminal in\nthe grammar, we write a function that recognizes strings produced from that\nnon-terminal. If there are multiple productions for the non-terminal, we use\nthe next available character to decide which one to use. To parse the right-hand\nside of the chosen production rule, we have to recognize a sequence of terminals\nand non-terminals in order. To recognize a terminal, we just check that the current\ncharacter from the input matches the expected symbol. To recognize a non-terminal,\nwe call the associated function for that non-terminal."]}),"\n",(0,a.jsxs)(t.p,{children:["Therefore, our parser will be a set of mutually recursive functions, one for each\nnon-terminal. To parse a word in the language, we call the function corresponding\nto the starting non-terminal; if that function returns without error, then we have\nsuccessfully matched a word. In addition to recognizing a string of characters, it\nis common for each recursive descent parsing function to return a data structure\n(the parse tree, or a close relative known as an ",(0,a.jsx)(t.strong,{children:"abstract syntax tree"}),") representing\nthe input that was parsed."]}),"\n",(0,a.jsxs)(t.p,{children:["Here is code for a recursive descent parser in Java, corresponding to the following\ngrammar (expressed here in ",(0,a.jsx)(t.a,{href:"/focsipedia2/docs/lang/bnf",children:"Backus-Naur form"}),"; it is very similar\nto the example ",(0,a.jsxs)(t.span,{className:"katex",children:[(0,a.jsx)(t.span,{className:"katex-mathml",children:(0,a.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(t.semantics,{children:[(0,a.jsx)(t.mrow,{children:(0,a.jsxs)(t.msub,{children:[(0,a.jsx)(t.mi,{children:"G"}),(0,a.jsx)(t.mn,{children:"2"})]})}),(0,a.jsx)(t.annotation,{encoding:"application/x-tex",children:"G_2"})]})})}),(0,a.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(t.span,{className:"base",children:[(0,a.jsx)(t.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,a.jsxs)(t.span,{className:"mord",children:[(0,a.jsx)(t.span,{className:"mord mathnormal",children:"G"}),(0,a.jsx)(t.span,{className:"msupsub",children:(0,a.jsxs)(t.span,{className:"vlist-t vlist-t2",children:[(0,a.jsxs)(t.span,{className:"vlist-r",children:[(0,a.jsx)(t.span,{className:"vlist",style:{height:"0.3011em"},children:(0,a.jsxs)(t.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[(0,a.jsx)(t.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(t.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(t.span,{className:"mord mtight",children:"2"})})]})}),(0,a.jsx)(t.span,{className:"vlist-s",children:"\u200b"})]}),(0,a.jsx)(t.span,{className:"vlist-r",children:(0,a.jsx)(t.span,{className:"vlist",style:{height:"0.15em"},children:(0,a.jsx)(t.span,{})})})]})})]})]})})]})," discussed in the ",(0,a.jsx)(t.a,{href:"/focsipedia2/docs/lang/parsing",children:"parsing"})," section):"]}),"\n",(0,a.jsx)(t.span,{className:"katex-display",children:(0,a.jsxs)(t.span,{className:"katex",children:[(0,a.jsx)(t.span,{className:"katex-mathml",children:(0,a.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,a.jsxs)(t.semantics,{children:[(0,a.jsxs)(t.mtable,{rowspacing:"0.25em",columnalign:"right left",columnspacing:"0em",children:[(0,a.jsxs)(t.mtr,{children:[(0,a.jsx)(t.mtd,{children:(0,a.jsx)(t.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,a.jsxs)(t.mrow,{children:[(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e8"}),(0,a.jsx)(t.mtext,{mathvariant:"italic",children:"Expr"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e9"}),(0,a.jsx)(t.mtext,{children:"\xa0"})]})})}),(0,a.jsx)(t.mtd,{children:(0,a.jsx)(t.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,a.jsxs)(t.mrow,{children:[(0,a.jsx)(t.mrow,{}),(0,a.jsx)(t.mo,{children:":"}),(0,a.jsx)(t.mo,{children:":"}),(0,a.jsx)(t.mo,{children:"="}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e8"}),(0,a.jsx)(t.mtext,{mathvariant:"italic",children:"Term"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e9"}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"["}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"("}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mo,{children:"+"}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mi,{mathvariant:"normal",children:"\u2223"}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mo,{children:"\u2212"}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mo,{stretchy:"false",children:")"}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e8"}),(0,a.jsx)(t.mtext,{mathvariant:"italic",children:"Term"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e9"}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"]"}),(0,a.jsx)(t.mo,{children:"\u2026"})]})})})]}),(0,a.jsxs)(t.mtr,{children:[(0,a.jsx)(t.mtd,{children:(0,a.jsx)(t.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,a.jsxs)(t.mrow,{children:[(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e8"}),(0,a.jsx)(t.mtext,{mathvariant:"italic",children:"Term"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e9"}),(0,a.jsx)(t.mtext,{children:"\xa0"})]})})}),(0,a.jsx)(t.mtd,{children:(0,a.jsx)(t.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,a.jsxs)(t.mrow,{children:[(0,a.jsx)(t.mrow,{}),(0,a.jsx)(t.mo,{children:":"}),(0,a.jsx)(t.mo,{children:":"}),(0,a.jsx)(t.mo,{children:"="}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e8"}),(0,a.jsx)(t.mtext,{mathvariant:"italic",children:"Factor"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e9"}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"["}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"("}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mo,{children:"\u2217"}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mi,{mathvariant:"normal",children:"\u2223"}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mi,{mathvariant:"normal",children:"/"}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mo,{stretchy:"false",children:")"}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e8"}),(0,a.jsx)(t.mtext,{mathvariant:"italic",children:"Factor"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e9"}),(0,a.jsx)(t.mtext,{children:"\xa0"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"]"}),(0,a.jsx)(t.mo,{children:"\u2026"})]})})})]}),(0,a.jsxs)(t.mtr,{children:[(0,a.jsx)(t.mtd,{children:(0,a.jsx)(t.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,a.jsxs)(t.mrow,{children:[(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e8"}),(0,a.jsx)(t.mtext,{mathvariant:"italic",children:"Factor"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e9"}),(0,a.jsx)(t.mtext,{children:"\xa0"})]})})}),(0,a.jsx)(t.mtd,{children:(0,a.jsx)(t.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,a.jsxs)(t.mrow,{children:[(0,a.jsx)(t.mrow,{}),(0,a.jsx)(t.mo,{children:":"}),(0,a.jsx)(t.mo,{children:":"}),(0,a.jsx)(t.mo,{children:"="}),(0,a.jsx)(t.mtext,{children:"\xa0ident\xa0"}),(0,a.jsx)(t.mi,{mathvariant:"normal",children:"\u2223"}),(0,a.jsx)(t.mtext,{children:"\xa0num\xa0"}),(0,a.jsx)(t.mi,{mathvariant:"normal",children:"\u2223"}),(0,a.jsx)(t.mtext,{children:"\xa0\u201c(\u201d\xa0"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e8"}),(0,a.jsx)(t.mtext,{mathvariant:"italic",children:"Expr"}),(0,a.jsx)(t.mo,{stretchy:"false",children:"\u27e9"}),(0,a.jsx)(t.mtext,{children:"\xa0\u201c)\u201d"})]})})})]})]}),(0,a.jsx)(t.annotation,{encoding:"application/x-tex",children:"\\begin{aligned}\n\\langle\\textit{Expr}\\rangle\\ &::=\\ \\langle\\textit{Term}\\rangle\\ [\\ (\\ +\\ |\\ -\\ )\\ \\langle\\textit{Term}\\rangle\\ ]\\ldots\\\\\n\\langle\\textit{Term}\\rangle\\ &::=\\ \\langle\\textit{Factor}\\rangle\\ [\\ (\\ *\\ |\\ /\\ )\\ \\langle\\textit{Factor}\\rangle\\ ]\\ldots\\\\\n\\langle\\textit{Factor}\\rangle\\ &::=\\ \\textrm{ident}\\ |\\ \\textrm{num}\\ |\\ \\textrm{``(''}\\ \\langle\\textit{Expr}\\rangle\\ \\textrm{``)''}\n\\end{aligned}"})]})})}),(0,a.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(t.span,{className:"base",children:[(0,a.jsx)(t.span,{className:"strut",style:{height:"4.5em",verticalAlign:"-2em"}}),(0,a.jsx)(t.span,{className:"mord",children:(0,a.jsxs)(t.span,{className:"mtable",children:[(0,a.jsx)(t.span,{className:"col-align-r",children:(0,a.jsxs)(t.span,{className:"vlist-t vlist-t2",children:[(0,a.jsxs)(t.span,{className:"vlist-r",children:[(0,a.jsxs)(t.span,{className:"vlist",style:{height:"2.5em"},children:[(0,a.jsxs)(t.span,{style:{top:"-4.66em"},children:[(0,a.jsx)(t.span,{className:"pstrut",style:{height:"3em"}}),(0,a.jsxs)(t.span,{className:"mord",children:[(0,a.jsx)(t.span,{className:"mopen",children:"\u27e8"}),(0,a.jsx)(t.span,{className:"mord text",children:(0,a.jsx)(t.span,{className:"mord textit",children:"Expr"})}),(0,a.jsx)(t.span,{className:"mclose",children:"\u27e9"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"})]})]}),(0,a.jsxs)(t.span,{style:{top:"-3.16em"},children:[(0,a.jsx)(t.span,{className:"pstrut",style:{height:"3em"}}),(0,a.jsxs)(t.span,{className:"mord",children:[(0,a.jsx)(t.span,{className:"mopen",children:"\u27e8"}),(0,a.jsx)(t.span,{className:"mord text",children:(0,a.jsx)(t.span,{className:"mord textit",children:"Term"})}),(0,a.jsx)(t.span,{className:"mclose",children:"\u27e9"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"})]})]}),(0,a.jsxs)(t.span,{style:{top:"-1.66em"},children:[(0,a.jsx)(t.span,{className:"pstrut",style:{height:"3em"}}),(0,a.jsxs)(t.span,{className:"mord",children:[(0,a.jsx)(t.span,{className:"mopen",children:"\u27e8"}),(0,a.jsx)(t.span,{className:"mord text",children:(0,a.jsx)(t.span,{className:"mord textit",children:"Factor"})}),(0,a.jsx)(t.span,{className:"mclose",children:"\u27e9"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"})]})]})]}),(0,a.jsx)(t.span,{className:"vlist-s",children:"\u200b"})]}),(0,a.jsx)(t.span,{className:"vlist-r",children:(0,a.jsx)(t.span,{className:"vlist",style:{height:"2em"},children:(0,a.jsx)(t.span,{})})})]})}),(0,a.jsx)(t.span,{className:"col-align-l",children:(0,a.jsxs)(t.span,{className:"vlist-t vlist-t2",children:[(0,a.jsxs)(t.span,{className:"vlist-r",children:[(0,a.jsxs)(t.span,{className:"vlist",style:{height:"2.5em"},children:[(0,a.jsxs)(t.span,{style:{top:"-4.66em"},children:[(0,a.jsx)(t.span,{className:"pstrut",style:{height:"3em"}}),(0,a.jsxs)(t.span,{className:"mord",children:[(0,a.jsx)(t.span,{className:"mord"}),(0,a.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(t.span,{className:"mrel",children:"::="}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(t.span,{className:"mopen",children:"\u27e8"}),(0,a.jsx)(t.span,{className:"mord text",children:(0,a.jsx)(t.span,{className:"mord textit",children:"Term"})}),(0,a.jsx)(t.span,{className:"mclose",children:"\u27e9"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mopen",children:"["}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mopen",children:"("}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mord",children:"+"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mord",children:"\u2223"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mord",children:"\u2212"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mclose",children:")"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mopen",children:"\u27e8"}),(0,a.jsx)(t.span,{className:"mord text",children:(0,a.jsx)(t.span,{className:"mord textit",children:"Term"})}),(0,a.jsx)(t.span,{className:"mclose",children:"\u27e9"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mclose",children:"]"}),(0,a.jsx)(t.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsx)(t.span,{className:"minner",children:"\u2026"})]})]}),(0,a.jsxs)(t.span,{style:{top:"-3.16em"},children:[(0,a.jsx)(t.span,{className:"pstrut",style:{height:"3em"}}),(0,a.jsxs)(t.span,{className:"mord",children:[(0,a.jsx)(t.span,{className:"mord"}),(0,a.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(t.span,{className:"mrel",children:"::="}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(t.span,{className:"mopen",children:"\u27e8"}),(0,a.jsx)(t.span,{className:"mord text",children:(0,a.jsx)(t.span,{className:"mord textit",children:"Factor"})}),(0,a.jsx)(t.span,{className:"mclose",children:"\u27e9"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mopen",children:"["}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mopen",children:"("}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mord",children:"\u2217"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mord",children:"\u2223"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mord",children:"/"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mclose",children:")"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mopen",children:"\u27e8"}),(0,a.jsx)(t.span,{className:"mord text",children:(0,a.jsx)(t.span,{className:"mord textit",children:"Factor"})}),(0,a.jsx)(t.span,{className:"mclose",children:"\u27e9"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mclose",children:"]"}),(0,a.jsx)(t.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsx)(t.span,{className:"minner",children:"\u2026"})]})]}),(0,a.jsxs)(t.span,{style:{top:"-1.66em"},children:[(0,a.jsx)(t.span,{className:"pstrut",style:{height:"3em"}}),(0,a.jsxs)(t.span,{className:"mord",children:[(0,a.jsx)(t.span,{className:"mord"}),(0,a.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(t.span,{className:"mrel",children:"::="}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(t.span,{className:"mord text",children:(0,a.jsx)(t.span,{className:"mord textrm",children:"ident"})}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mord",children:"\u2223"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mord text",children:(0,a.jsx)(t.span,{className:"mord textrm",children:"num"})}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mord",children:"\u2223"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mord text",children:(0,a.jsx)(t.span,{className:"mord textrm",children:"\u201c(\u201d"})}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mopen",children:"\u27e8"}),(0,a.jsx)(t.span,{className:"mord text",children:(0,a.jsx)(t.span,{className:"mord textit",children:"Expr"})}),(0,a.jsx)(t.span,{className:"mclose",children:"\u27e9"}),(0,a.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,a.jsx)(t.span,{className:"mord text",children:(0,a.jsx)(t.span,{className:"mord textrm",children:"\u201c)\u201d"})})]})]})]}),(0,a.jsx)(t.span,{className:"vlist-s",children:"\u200b"})]}),(0,a.jsx)(t.span,{className:"vlist-r",children:(0,a.jsx)(t.span,{className:"vlist",style:{height:"2em"},children:(0,a.jsx)(t.span,{})})})]})})]})})]})})]})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:"/**\n * Represents an expression node in an abstract syntax tree.\n */\npublic interface Expr {\n\t// instance methods appropriate to the application should be declared here\n\n\t/**\n\t * Parse an expression (sum/difference of one or more terms).\n\t * \n\t * @param input\n\t * @return\n\t */\n\tpublic static Expr parse(Input input) {\n\t\tExpr e = parseTerm(input);\n\t\twhile (input.peek() == '+' || input.peek() == '-') {\n\t\t\tBinOp op = BinOp.parse(input);\n\t\t\tExpr e2 = Expr.parseTerm(input);\n\t\t\te = new BinOpExpr(e, op, e2);\n\t\t}\n\t\treturn e;\n\t}\n\n\t/**\n\t * Parse a term (product/quotient of one or more factors).\n\t * \n\t * @param input\n\t * @return\n\t */\n\tpublic static Expr parseTerm(Input input) {\n\t\tExpr e = parseFactor(input);\n\t\twhile (input.peek() == '*' || input.peek() == '/') {\n\t\t\tBinOp op = BinOp.parse(input);\n\t\t\tExpr e2 = Expr.parseFactor(input);\n\t\t\te = new BinOpExpr(e, op, e2);\n\t\t}\n\t\treturn e;\n\t}\n\n\t/**\n\t * Parse a factor (identifier, number, or parenthesized expression). Throws a\n\t * RuntimeException if a factor is not available.\n\t * \n\t * @param input\n\t * @return\n\t */\n\tpublic static Expr parseFactor(Input input) {\n\t\tif (Character.isLetter(input.peek())) {\n\t\t\tString id = input.readIdent();\n\t\t\treturn new IdentExpr(id);\n\t\t} else if (Character.isDigit(input.peek())) {\n\t\t\tint n = input.readInt();\n\t\t\treturn new NumExpr(n);\n\t\t} else if (input.peek() == '(') {\n\t\t\tinput.skip();\n\t\t\tExpr e = parse(input);\n\t\t\tinput.match(')');\n\t\t\treturn e;\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"expected a factor\");\n\t\t}\n\t}\n}\n\npublic class BinOpExpr implements Expr {\n\tprivate Expr left, right;\n\tprivate BinOp op;\n\n\tpublic BinOpExpr(Expr left, BinOp op, Expr right) {\n\t\tthis.left = left;\n\t\tthis.op = op;\n\t\tthis.right = right;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"BinOp(\" + left + \", \" + op + \", \" + right + \")\";\n\t}\n}\n\npublic class IdentExpr implements Expr {\n\tprivate String id;\n\n\tpublic IdentExpr(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Ident(\" + id + \")\";\n\t}\n}\n\npublic class NumExpr implements Expr {\n\tprivate int n;\n\n\tpublic NumExpr(int n) {\n\t\tthis.n = n;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Num(\" + n + \")\";\n\t}\n}\n\n/**\n * Represents the binary operators available in the abstract syntax for\n * expressions.\n */\npublic enum BinOp {\n\tPLUS, MINUS, TIMES, DIVIDE;\n\n\t/**\n\t * Parse a binary operator from the given Input. Should only be called when the\n\t * current character may start an operator.\n\t * \n\t * @param input\n\t * @return\n\t */\n\tstatic BinOp parse(Input input) {\n\t\tswitch (input.peek()) {\n\t\tcase '+':\n\t\t\tinput.skip();\n\t\t\treturn PLUS;\n\t\tcase '-':\n\t\t\tinput.skip();\n\t\t\treturn MINUS;\n\t\tcase '*':\n\t\t\tinput.skip();\n\t\t\treturn TIMES;\n\t\tcase '/':\n\t\t\tinput.skip();\n\t\t\treturn DIVIDE;\n\t\tdefault:\n\t\t\treturn null; // shouldn't happen\n\t\t}\n\t}\n}\n\n/**\n * Wrapper around a Reader that provides useful abstractions for recursive\n * descent parsing.\n */\npublic class Input {\n\tprivate java.io.Reader source;\n\tprivate char next;\n\tprivate boolean atEnd;\n\n\tpublic Input(java.io.Reader source) {\n\t\tthis.source = source;\n\t\tskip();\n\t}\n\n\t/**\n\t * @return current available character\n\t */\n\tpublic char peek() {\n\t\treturn next;\n\t}\n\n\t/**\n\t * @return true if no more characters available\n\t */\n\tpublic boolean atEnd() {\n\t\treturn atEnd;\n\t}\n\n\t/**\n\t * Read the next available character, skipping over whitespace\n\t */\n\tpublic void skip() {\n\t\treadNext();\n\t\tskipWhitespace();\n\t}\n\n\t/**\n\t * If the current character is c, skip to the next. Throw a RuntimeException if\n\t * the character does not match.\n\t * \n\t * @param c\n\t */\n\tpublic void match(char c) {\n\t\tif (next == c) {\n\t\t\tskip();\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"expected \" + c + \" but found \" + next);\n\t\t}\n\t}\n\n\t/**\n\t * Read an identifier (letter followed by zero or more letters or digits). This\n\t * should only be called when the current character is a letter.\n\t * \n\t * @return the identifier\n\t */\n\tpublic String readIdent() {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tbuilder.append(next);\n\t\treadNext();\n\t\twhile (!atEnd && Character.isLetterOrDigit(next)) {\n\t\t\tbuilder.append(next);\n\t\t\treadNext();\n\t\t}\n\t\tskipWhitespace();\n\t\treturn builder.toString();\n\t}\n\n\t/**\n\t * Read an integer (digit followed by zero or more additional digits). This\n\t * should only be called when the current character is a digit.\n\t * \n\t * @return the number\n\t */\n\tpublic int readInt() {\n\t\tint result = next - '0';\n\t\treadNext();\n\t\twhile (!atEnd && Character.isDigit(next)) {\n\t\t\tresult = result * 10 + next - '0';\n\t\t\treadNext();\n\t\t}\n\t\tskipWhitespace();\n\t\treturn result;\n\t}\n\n\tprivate void readNext() {\n\t\ttry {\n\t\t\tint c = source.read();\n\t\t\tif (c != -1) {\n\t\t\t\tnext = (char) c;\n\t\t\t\tatEnd = false;\n\t\t\t} else {\n\t\t\t\tnext = '\\0';\n\t\t\t\tatEnd = true;\n\t\t\t}\n\t\t} catch (java.io.IOException e) {\n\t\t\tnext = '\\0';\n\t\t\tatEnd = true;\n\t\t}\n\t}\n\n\tprivate void skipWhitespace() {\n\t\twhile (!atEnd && Character.isWhitespace(next)) {\n\t\t\treadNext();\n\t\t}\n\t}\n}\n\npublic class Demo {\n\tpublic static void main(String[] args) {\n\t\tString sample = \"  3*abc + (x1 - x0) * r2d2/42 \\n\";\n\t\tInput input = new Input(new StringReader(sample));\n\t\tExpr e = Expr.parse(input);\n\t\tif (input.atEnd()) {\n\t\t\tSystem.out.println(\"Found \" + e);\n\t\t} else {\n\t\t\tSystem.out.println(\"unscanned input after parsing \" + e);\n\t\t}\n\t}\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"parser-combinators",children:"Parser Combinators"}),"\n",(0,a.jsxs)(t.p,{children:["Instead of giving a direct translation of the Java version into Scala, it is\ncommon in functional languages to use what are known as ",(0,a.jsx)(t.strong,{children:"parser combinators"}),'\nto write recursive descent parsers. A parser is viewed as a function from input\nto the pair of a result plus the remaining input (since in a functional language\nwe do not want to use side-effects to update the "current character" available from\nan input source). A parser combinator is then a function that can combine one or\nmore of these parsing functions into a composite parser.']}),"\n",(0,a.jsxs)(t.p,{children:["The example below uses the\n",(0,a.jsx)(t.a,{href:"https://com-lihaoyi.github.io/fastparse/",children:"FastParse combinator parsing library"}),".\nFor example, given parsers ",(0,a.jsx)(t.code,{children:"p1"})," and ",(0,a.jsx)(t.code,{children:"p2"}),", the combinator ",(0,a.jsx)(t.code,{children:"|"})," produces the parser\n",(0,a.jsx)(t.code,{children:"p1 | p2"})," which attempts to parse according to ",(0,a.jsx)(t.code,{children:"p1"}),"; if it fails, then it attempts\nto use ",(0,a.jsx)(t.code,{children:"p2"})," instead. This corresponds to the ",(0,a.jsxs)(t.span,{className:"katex",children:[(0,a.jsx)(t.span,{className:"katex-mathml",children:(0,a.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(t.semantics,{children:[(0,a.jsx)(t.mrow,{children:(0,a.jsx)(t.mi,{mathvariant:"normal",children:"\u2223"})}),(0,a.jsx)(t.annotation,{encoding:"application/x-tex",children:"|"})]})})}),(0,a.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(t.span,{className:"base",children:[(0,a.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(t.span,{className:"mord",children:"\u2223"})]})})]})," (choice) operator in BNF (and also\nin regular expressions). Some of the other combinators used below are ",(0,a.jsx)(t.code,{children:"~"}),", which\ncorresponds to sequencing one parser after another, and ",(0,a.jsx)(t.code,{children:"rep"}),", which repeats a\nparser zero or more times (like the Kleene star).\nThe ",(0,a.jsx)(t.code,{children:"map"})," operations take the result of parsing a particular rule and construct the\ndesired abstract syntax tree of type ",(0,a.jsx)(t.code,{children:"Expr"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Here is the parser for arithmetic expressions, corresponding to the Java example above.\nNote how the definitions of ",(0,a.jsx)(t.code,{children:"expr"}),", ",(0,a.jsx)(t.code,{children:"term"}),", and ",(0,a.jsx)(t.code,{children:"factor"})," are very close to the original BNF:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:'package test\n\nenum Expr:\n  case Ident(name: String)\n  case Num(value: Int)\n  case BinOp(left: Expr, op: String, right: Expr)\nimport Expr.*\n\nimport fastparse._, SingleLineWhitespace._\n\nobject ExprParse:\n  def apply(input: String): Either[String, Expr] = {\n    parse(input, { case given P[_] => top }) match\n    case Parsed.Success(value, _) => Right(value)\n    case result: Parsed.Failure => Left(result.msg)\n  }\n    \n  def top[$: P]: P[Expr] = P ( Start ~ expr ~ End )\n\n  def expr[$: P]: P[Expr] = P( term ~ (addOp ~ term).rep )\n    .map {\n        case (t, rest) => rest.foldLeft(t) { case (e1, (op, e2)) => BinOp(e1, op, e2) }\n    }\n\n  def term[$: P]: P[Expr] = P( factor ~ (mulOp ~ factor).rep )\n    .map {\n        case (f, rest) => rest.foldLeft(f) { case (e1, (op, e2)) => BinOp(e1, op, e2) }\n    }\n\n  def factor[$: P]: P[Expr] = P( id | num | "(" ~ expr ~ ")" )\n\n  def id[$: P]: P[Expr] = P( ident.map(Ident(_)) )\n\n  def num[$: P]: P[Expr] = P( number.map(n => Num(n.toInt)) )\n\n  // Lexical Syntax\n  def ident[$: P] = P( CharIn("A-Za-z").! ~~ CharsWhileIn("A-Za-z0-9").?.! )\n    .map {\n        case (init, rest) => init + rest\n    }\n\n  def number[$: P] = P( ("-".? ~~ CharsWhileIn("0-9")).! )\n\n  def addOp[$: P] = P( ("+" | "-").! )\n\n  def mulOp[$: P] = P( ("*" | "/").! )\n\n  @main def demo(): Unit = {\n    val input = "a*x*x + b*x + c"\n\n    ExprParse(input) match\n        case Right(expr) =>\n          println(expr)\n        case Left(message) =>\n          println("Error: " + message)\n  }\n'})})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>c});var n=s(96540);const a={},r=n.createContext(a);function i(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);