"use strict";(self.webpackChunkfocsipedia=self.webpackChunkfocsipedia||[]).push([[2594],{3686:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var t=s(4848),r=s(8453);const a={id:"trees",title:"Trees"},i=void 0,o={id:"ds/trees",title:"Trees",description:"Binary Trees",source:"@site/focsipedia-docs/target/mdoc/ds/trees.md",sourceDirName:"ds",slug:"/ds/trees",permalink:"/focsipedia2/docs/ds/trees",draft:!1,unlisted:!1,editUrl:"https://github.com/bhoward/focsipedia2/tree/main/focsipedia-docs/target/mdoc/ds/trees.md",tags:[],version:"current",frontMatter:{id:"trees",title:"Trees"},sidebar:"mySidebar",previous:{title:"Program Verification",permalink:"/focsipedia2/docs/ds/verification"},next:{title:"Binary Search Trees and Heaps",permalink:"/focsipedia2/docs/ds/bst"}},l={},c=[{value:"Binary Trees",id:"binary-trees",level:2},{value:"Traversals",id:"traversals",level:3},{value:"Expression Trees",id:"expression-trees",level:3},{value:"Exercises",id:"exercises",level:2}];function h(e){const n={a:"a",annotation:"annotation",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",ol:"ol",p:"p",pre:"pre",section:"section",semantics:"semantics",span:"span",strong:"strong",sup:"sup",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"binary-trees",children:"Binary Trees"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"binary tree"})," is a data structure that is either empty or it consists of a root node with three pieces of data:\na value (often a number or a string), and two subtrees, one on the left and one on the right.\nThis can be expressed with the following recursive data type in Scala:",(0,t.jsx)(n.sup,{children:(0,t.jsx)(n.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"enum Tree[+T]:\n  case Empty\n  case Node(left: Tree[T], value: T, right: Tree[T])\n\ndef leaf[T](value: T): Tree[T] = {\n  Tree.Node(Tree.Empty, value, Tree.Empty)\n}\n\nval demo = Tree.Node(leaf(1), 2, Tree.Node(leaf(3), 4, leaf(5)))\n// demo: Tree[Int] = Node(\n//   left = Node(left = Empty, value = 1, right = Empty),\n//   value = 2,\n//   right = Node(\n//     left = Node(left = Empty, value = 3, right = Empty),\n//     value = 4,\n//     right = Node(left = Empty, value = 5, right = Empty)\n//   )\n// )\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We use a type variable ",(0,t.jsx)(n.code,{children:"T"})," as a parameter to specify the type of values in the tree.\nThe function ",(0,t.jsx)(n.code,{children:"leaf"})," is a convenience, so that we can write ",(0,t.jsx)(n.code,{children:"leaf(1)"})," for the tree with just the value 1 and two empty children instead of ",(0,t.jsx)(n.code,{children:"Tree.Node(Tree.Empty, 1, Tree.Empty)"}),".\nIn this case, it will infer that the type parameter ",(0,t.jsx)(n.code,{children:"T"})," should be ",(0,t.jsx)(n.code,{children:"Int"}),", so we get a ",(0,t.jsx)(n.code,{children:"Tree[Int]"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Note the similarity to a list of type ",(0,t.jsx)(n.code,{children:"List[T]"}),", which is either an empty list or a list node with a head value\n(of type ",(0,t.jsx)(n.code,{children:"T"}),") and a sublist of the rest of the elements (the tail)."]}),"\n",(0,t.jsx)(n.p,{children:"The natural way to write a function that takes a binary tree is to use (surprise) Pattern Matching,\nwhich corresponds to doing structural induction over the construction of the tree.\nFor example, suppose we want to know how many nodes a tree has:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'def size[T](t: Tree[T]): Int = {\n  t match\n    case Tree.Empty => 0\n    case Tree.Node(left, _, right) => size(left) + 1 + size(right)\n}\n\nsize(Tree.Empty)\n// res0: Int = 0\nsize(leaf("hello"))\n// res1: Int = 1\nsize(demo)\n// res2: Int = 5\n'})}),"\n",(0,t.jsx)(n.p,{children:"If we have a list with integer values, we might want to get the total of all the values in the tree:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"def total(t: Tree[Int]): Int = {\n  t match\n    case Tree.Empty => 0\n    case Tree.Node(left, value, right) => total(left) + value + total(right)\n}\n\ntotal(Tree.Empty)\n// res3: Int = 0\ntotal(demo)\n// res4: Int = 15\n"})}),"\n",(0,t.jsxs)(n.p,{children:["A useful function on trees will be to have a visualization of the tree.\nHere is a simple rendering of a tree with ",(0,t.jsx)(n.a,{href:"/focsipedia2/docs/fp/doodle",children:"Doodle"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val EMPTY_WIDTH = 5\nval NODE_WIDTH = 20\nval HSPACE = 30\nval VSPACE = 30\n\ndef showTreeWidth[T](t: Tree[T]): Double = {\n  t match\n    case Tree.Empty => EMPTY_WIDTH\n    case Tree.Node(left, _, right) =>\n      showTreeWidth(left) + HSPACE + showTreeWidth(right)\n}\n\ndef showTree[T](t: Tree[T]): Image = {\n  t match\n    case Tree.Empty => Image.circle(EMPTY_WIDTH).fillColor(Color.black)\n    case Tree.Node(left, value, right) =>\n      val showLeft = showTree(left)\n      val showRight = showTree(right)\n      val leftShift = (showTreeWidth(left) + HSPACE) / 2\n      val rightShift = (showTreeWidth(right) + HSPACE) / 2\n      val leftLine = Image.path(OpenPath.empty.lineTo(leftShift, VSPACE))\n      val rightLine = Image.path(OpenPath.empty.lineTo(-rightShift, VSPACE))\n      val leftImage = showLeft `on` leftLine\n      val rightImage = showRight `on` rightLine\n      Image.text(value.toString) `on`\n        Image.square(NODE_WIDTH).fillColor(Color.white) `on`\n        leftImage.originAt(Landmark.topRight) `on`\n        rightImage.originAt(Landmark.topLeft)\n}\n\nval treeDemo = showTree(demo)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Doodle",src:s(570).A+"",width:"206",height:"126"})}),"\n",(0,t.jsx)(n.h3,{id:"traversals",children:"Traversals"}),"\n",(0,t.jsxs)(n.p,{children:["Processing a binary tree is often expressed as a ",(0,t.jsx)(n.strong,{children:"traversal"}),".\nThere are several common tree traversals:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Preorder"}),": To process a non-empty tree, first process the value in its root node, then process the left child followed by the right child."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Inorder"}),": To process a non-empty tree, first process the left child, then the value in the root node, and finally the right child."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Postorder"}),": To process a non-empty tree, first process the left child, then the right child, and finish with the value in the root node."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Level order"}),": Process the value in the root node, then process the values in its children from left to right, then process its children's children from left to right, and so on, until there are no more nodes."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The first three traversals have very easy recursive implementations. For example, here is the preorder traversal,\nwhich takes a ",(0,t.jsx)(n.code,{children:"Tree[T]"})," and a function ",(0,t.jsx)(n.code,{children:"process: T => Unit"})," (the return type of ",(0,t.jsx)(n.code,{children:"Unit"})," is a sign that we are\nexpecting ",(0,t.jsx)(n.code,{children:"process"})," to have a side-effect, such as printing, instead of returning a value):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"def preOrder[T](t: Tree[T], process: T => Unit): Unit = {\n  t match\n    case Tree.Empty => ()\n    case Tree.Node(left, value, right) =>\n      process(value)\n      preOrder(left, process)\n      preOrder(right, process)\n}\n\npreOrder(demo, print)\n// 21435\n"})}),"\n",(0,t.jsx)(n.p,{children:"We will have to wait a bit to learn how to do the level order traversal."}),"\n",(0,t.jsxs)(n.p,{children:["To see an interesting connection between traversals and programming languages, we will consider a variation on binary trees called ",(0,t.jsx)(n.strong,{children:"expression trees"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"expression-trees",children:"Expression Trees"}),"\n",(0,t.jsxs)(n.p,{children:["An expression tree represents the structure of an expression.\nThis could be an arithmetic expression, such as ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsx)(n.mn,{children:"1"}),(0,t.jsx)(n.mo,{children:"+"}),(0,t.jsx)(n.mn,{children:"2"}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"}),(0,t.jsx)(n.mo,{children:"\u22c5"}),(0,t.jsx)(n.mn,{children:"3"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"(1+2)\\cdot 3"})]})})}),(0,t.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsx)(n.span,{className:"mord",children:"1"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(n.span,{className:"mbin",children:"+"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord",children:"2"}),(0,t.jsx)(n.span,{className:"mclose",children:")"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(n.span,{className:"mbin",children:"\u22c5"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,t.jsx)(n.span,{className:"mord",children:"3"})]})]})]}),", or a boolean expression such as ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsx)(n.mi,{children:"p"}),(0,t.jsx)(n.mo,{children:"\u2228"}),(0,t.jsx)(n.mi,{children:"q"}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"}),(0,t.jsx)(n.mo,{children:"\u2227"}),(0,t.jsx)(n.mi,{children:"r"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"(p\\lor q)\\land r"})]})})}),(0,t.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"p"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(n.span,{className:"mbin",children:"\u2228"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"q"}),(0,t.jsx)(n.span,{className:"mclose",children:")"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(n.span,{className:"mbin",children:"\u2227"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"r"})]})]})]}),";\nit also generalizes to expressions in a programming language, such as ",(0,t.jsx)(n.code,{children:"if a < b then c else d"})," in Scala.\nFor now we will limit our consideration to expressions with boolean operators and integer operands,\nwhich can be described by the following recursive type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'enum Expr:\n  case Const(c: Int)\n  case BinOp(left: Expr, op: String, right: Expr)\n\nimport Expr.*\nval sample = BinOp(BinOp(Const(1), "+", Const(2)), "*", Const(3))\n// sample: Expr = BinOp(\n//   left = BinOp(left = Const(c = 1), op = "+", right = Const(c = 2)),\n//   op = "*",\n//   right = Const(c = 3)\n// )\n'})}),"\n",(0,t.jsx)(n.p,{children:"Now we may define functions that perform preorder, inorder, and postorder traversals of expression trees\nto produce string representations of an expression:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'def prefix(e: Expr): String = {\n  e match\n    case Const(n) => n.toString\n    case BinOp(left, op, right) =>\n      String.format("%s(%s, %s)", op, prefix(left), prefix(right))\n}\n\ndef infix(e: Expr): String = {\n  e match\n    case Const(n) => n.toString\n    case BinOp(left, op, right) =>\n      String.format("(%s %s %s)", infix(left), op, infix(right))\n}\n\ndef postfix(e: Expr): String = {\n  e match\n    case Const(n) => n.toString\n    case BinOp(left, op, right) =>\n      String.format("%s %s %s", postfix(left), postfix(right), op)\n}\n\nprefix(sample)\n// res7: String = "*(+(1, 2), 3)"\ninfix(sample)\n// res8: String = "((1 + 2) * 3)"\npostfix(sample)\n// res9: String = "1 2 + 3 *"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The preorder traversal of an expression tree gives the ",(0,t.jsx)(n.strong,{children:"prefix"})," form of the expression, where the operator comes in front of both of its operands.\nWith the extra parentheses and commas added above, you can see that this is our familiar function call notation: ",(0,t.jsx)(n.code,{children:"+(1, 2)"})," is just the application of the addition function to the arguments ",(0,t.jsx)(n.code,{children:"1"})," and ",(0,t.jsx)(n.code,{children:"2"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The inorder traversal of an expression tree gives the ",(0,t.jsx)(n.strong,{children:"infix"})," form of the expression, where the operator takes its usual position between its operands.\nThe extra parentheses are essential here, to avoid the ambiguity of whether ",(0,t.jsx)(n.code,{children:"1 + 2 * 3"})," is an addition of ",(0,t.jsx)(n.code,{children:"1"})," and ",(0,t.jsx)(n.code,{children:"2 * 3"}),", or whether it is a multiplication of ",(0,t.jsx)(n.code,{children:"1 + 2"})," by ",(0,t.jsx)(n.code,{children:"3"}),".\nIn practical use we get around this by adopting conventions of ",(0,t.jsx)(n.strong,{children:"precedence"}),", saying for example that multiplication takes precedence over addition, so that ",(0,t.jsx)(n.code,{children:"1 + 2 * 3"})," has an addition operator at the root.\nIn the sample expression tree, however, the multiplication is at the root, so we have to insert at least one pair of parentheses to get the correct expression: ",(0,t.jsx)(n.code,{children:"(1 + 2) * 3"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The postorder traversal of an expression tree gives the ",(0,t.jsx)(n.strong,{children:"postfix"})," form of the expression, which may not be as familiar.\nBack in the Dark Ages",(0,t.jsx)(n.sup,{children:(0,t.jsx)(n.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})})," of computing, Hewlett-Packard made a series of powerful calculators that became very popular, particularly with engineers.\nAt the time, calculators were not able to handle arbitrarily complex infix expressions (many of them didn't even have parentheses\u2026), and HP's solution was elegant: use postfix instead of infix!\nThey referred to this as Reverse Polish Notation (RPN) in honor of the logician Jan \u0141ukasiewicz (1878\u20131956), who invented postfix in the 1920's as a way to write logical expressions without parentheses."]}),"\n",(0,t.jsxs)(n.p,{children:["The key to interpreting a postfix expression is to imagine maintaining a ",(0,t.jsx)(n.strong,{children:"stack"})," of values as you read from left to right.\nWhen you see a number, ",(0,t.jsx)(n.em,{children:"push"})," that value onto the stack.\nWhen you see an operator, since it must be following its two operands, ",(0,t.jsx)(n.em,{children:"pop"})," two values from the stack, perform the operation, and ",(0,t.jsx)(n.em,{children:"push"})," the result back on the stack.\nFor the sample above, ",(0,t.jsx)(n.code,{children:"1 2 + 3 *"}),", you can check that the resulting value on the stack at the end of the expression is the expected ",(0,t.jsx)(n.code,{children:"9"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"More recent uses of postfix expressions and stack-based evaluation are the PostScript page description language used by many printers (which also forms the basis of the PDF document format), and the Java Virtual Machine code produced by the Java compiler."}),"\n",(0,t.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsx)(n.p,{children:"TBD"}),"\n","\n",(0,t.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,t.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{id:"user-content-fn-1",children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"+"})," in ",(0,t.jsx)(n.code,{children:"enum Tree[+T]"})," is there as a convenience, for reasons that we will mostly ignore.\nIf you want to know, it is marking ",(0,t.jsx)(n.code,{children:"Tree"})," as a ",(0,t.jsx)(n.strong,{children:"covariant"})," type constructor, which means that if ",(0,t.jsx)(n.code,{children:"S"})," is a\nsubtype of ",(0,t.jsx)(n.code,{children:"T"}),", then ",(0,t.jsx)(n.code,{children:"Tree[S]"})," will also be a subtype of ",(0,t.jsx)(n.code,{children:"Tree[T]"}),".\nThe convenience comes in because the actual type of ",(0,t.jsx)(n.code,{children:"Tree.Empty"})," is ",(0,t.jsx)(n.code,{children:"Tree[Nothing]"}),", but since ",(0,t.jsx)(n.code,{children:"Nothing"})," is a\nsubtype of every other type, this means that it also has type ",(0,t.jsx)(n.code,{children:"Tree[T]"})," for any ",(0,t.jsx)(n.code,{children:"T"}),", so we can use the same\nempty tree value in any tree.\nThere are also ",(0,t.jsx)(n.strong,{children:"contravariant"})," type constructors, indicated with a ",(0,t.jsx)(n.code,{children:"-"}),", where the subtyping goes the\nother way around, but we will not need them here. ",(0,t.jsx)(n.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{id:"user-content-fn-2",children:["\n",(0,t.jsxs)(n.p,{children:["The 1970's. See ",(0,t.jsx)(n.a,{href:"https://www.hpmuseum.org/rpn.htm",children:"https://www.hpmuseum.org/rpn.htm"})," for more details on RPN. ",(0,t.jsx)(n.a,{href:"#user-content-fnref-2","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},570:(e,n,s)=>{s.d(n,{A:()=>t});const t="data:image/png;base64,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"},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var t=s(6540);const r={},a=t.createContext(r);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);