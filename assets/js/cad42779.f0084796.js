"use strict";(self.webpackChunkfocsipedia=self.webpackChunkfocsipedia||[]).push([[2438],{8240:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var t=s(4848),r=s(8453);const o={id:"verification",title:"Program Verification"},i=void 0,a={id:"ds/verification",title:"Program Verification",description:"How do you know that a program is correct?",source:"@site/focsipedia-docs/target/mdoc/ds/verification.md",sourceDirName:"ds",slug:"/ds/verification",permalink:"/focsipedia2/docs/ds/verification",draft:!1,unlisted:!1,editUrl:"https://github.com/bhoward/focsipedia2/tree/main/focsipedia-docs/target/mdoc/ds/verification.md",tags:[],version:"current",frontMatter:{id:"verification",title:"Program Verification"},sidebar:"mySidebar",previous:{title:"Running Time and Recurrences",permalink:"/focsipedia2/docs/ds/recurrence"},next:{title:"Trees",permalink:"/focsipedia2/docs/ds/trees"}},l={},c=[{value:"Testing",id:"testing",level:2},{value:"Assertions",id:"assertions",level:2},{value:"Property Testing",id:"property-testing",level:2},{value:"Correctness Proofs",id:"correctness-proofs",level:2},{value:"Exercises",id:"exercises",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:['How do you know that a program is correct?\nThe first issue is to decide what it even means for a program to be correct: if it isn\'t\nfully clear what the correct output should be for a given input, then we have no chance\nof saying anything more definite than "it looks OK".\nTherefore, we will assume that we start with some sort of ',(0,t.jsx)(n.strong,{children:"specification"}),", whether\nformal or informal, that will let us recognize correct output."]}),"\n",(0,t.jsx)(n.p,{children:"Given a specification, there is a wide spectrum of approaches to establishing the correctness\nof a program:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Do nothing and rely on the programmer to write code that works; this is clearly not reliable\nor maintainable."}),"\n",(0,t.jsxs)(n.li,{children:["Provide informal arguments, perhaps in the form of ",(0,t.jsx)(n.strong,{children:"comments"})," embedded in the source code,\nexplaining how parts of the program work and correspond to the desired behavior; this may be\nas far as some programmers go, and while it may be better in terms of maintainability, it\ndoes not provide much additional assurance of correctness."]}),"\n",(0,t.jsx)(n.li,{children:"Create a suite of test cases, with sample inputs and expected outputs;\nif a program passes its test suite, that gives some confidence that it might be correct, but\nit can only tell about the particular cases that were in the suite; it provides no guarantees\nabout the behavior on untested cases."}),"\n",(0,t.jsxs)(n.li,{children:["Some aspects of a specification may be expressed in code in the form of ",(0,t.jsx)(n.strong,{children:"assertions"}),".\nAn assertion is a boolean expression that can be evaluated at some point of program execution;\nif the result is ",(0,t.jsx)(n.code,{children:"false"}),", then the assertion has failed.\nYou will only know this when the program is run on a particular input that triggers the failure;\nthis is analogous to dynamically typed languages like Python, where you will only find out about\na type violation when it actually occurs during program execution (potentially when it is in\nproduction use by the client\u2026)."]}),"\n",(0,t.jsxs)(n.li,{children:["One way to combine the previous two approaches is known as ",(0,t.jsx)(n.strong,{children:"property-based testing"}),', where\na testing tool will automatically generate a large number of test cases based on assertions\n("properties") attached to the code. Again, passing a finite number of tests can never guarantee\nthe absence of bugs, because the tool might not happen to generate a particular failing case,\nbut good property-based testers can check a large range of common problem areas, such as\n',(0,t.jsx)(n.strong,{children:"edge cases"})," near extremely large or small inputs, or ",(0,t.jsx)(n.strong,{children:"corner cases"})," with unusual\ncombinations of inputs."]}),"\n",(0,t.jsxs)(n.li,{children:["To gain full confidence that a program satisfies its specification, one can develop a\nformal ",(0,t.jsx)(n.strong,{children:"correctness proof"}),". If successful, this provides a guarantee of correctness for all\npossible program executions; again, this is analogous to strong statically typed languages\nlike Scala, where once the compiler confirms the types of all entities in advance, there\nis no need to recheck them dynamically (during execution). Type checking can be thought of as\na simple form of correctness proof, where the assertions only make claims about\nbroad sets of possible values (the types)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"More details and examples of testing, assertions, properties, and correctness proofs are below."}),"\n",(0,t.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,t.jsxs)(n.p,{children:["The tests in a test suite can be on the level of individual functions to be tested in isolation\n(",(0,t.jsx)(n.strong,{children:"unit testing"}),"), or they can be\nat the level of a full program with inputs and outputs as seen by a user (",(0,t.jsx)(n.strong,{children:"integration testing"}),").\nIn the following, we will only be looking at examples of unit testing.\nFrequently the running of the test suite will be automated, so that the programmer will get\nfeedback after every change to know whether any of the test cases fail."]}),"\n",(0,t.jsxs)(n.p,{children:["As noted above, testing can only confirm correct behavior on the cases where someone thought to\nwrite a test.\nThis can still be valuable, particularly in the form of ",(0,t.jsx)(n.strong,{children:"regression testing"}),", where tests\nare added to the suite whenever a bug is discovered\u2014by adding a test that would\nhave failed because of the bug, passing the enhanced suite in the future will not only check that the\nbug has been fixed (at least for that particular case), but also provides confidence that\nfurther changes to the code do not reintroduce old bugs."]}),"\n",(0,t.jsxs)(n.p,{children:["Here is an example (adapted from\n",(0,t.jsx)(n.a,{href:"https://github.com/anshulxyz/algorithms-scala/blob/main/src/test/scala/example/InsertionSortSpec.scala",children:"this source"}),")\nof using the ",(0,t.jsx)(n.a,{href:"https://www.scalatest.org",children:"ScalaTest"})," framework to test some cases\nof the ",(0,t.jsx)(n.code,{children:"insertion_sort"})," function from ",(0,t.jsx)(n.a,{href:"/focsipedia2/docs/ds/lists",children:"Sorting Lists"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'class InsertionSortSpec extends AnyFlatSpec with Matchers:\n  "Insertion Sort" should "sort a list of integers in ascending order" in {\n    val unsortedList = List(4, 6, 1, 3, 5)\n    val sortedList   = List(1, 3, 4, 5, 6)\n    insertion_sort(unsortedList) shouldEqual sortedList\n  }\n\n  it should "handle an empty list" in {\n    insertion_sort(Nil) shouldEqual Nil\n  }\n\n  it should "handle a list with a single element" in {\n    val singleElementList = List(42)\n    insertion_sort(singleElementList) shouldEqual singleElementList\n  }\n\n  it should "handle a list with duplicate elements" in {\n    val listWithDuplicates = List(3, 1, 4, 1, 5, 9, 2, 6, 5)\n    val sortedlist         = List(1, 1, 2, 3, 4, 5, 5, 6, 9)\n    insertion_sort(listWithDuplicates) shouldEqual sortedlist\n  }\n'})}),"\n",(0,t.jsx)(n.p,{children:"The output when this is run with ScalaTest will look something like this:"}),"\n",(0,t.jsx)("pre",{children:(0,t.jsxs)(n.p,{children:["[info] ",(0,t.jsx)("span",{style:{color:"green"},children:"InsertionSortSpec:"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"green"},children:"Insertion Sort"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"green"},children:"- should sort a list of integers in ascending order"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"green"},children:"- should handle an empty list"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"green"},children:"- should handle a list with a single element"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"green"},children:"- should handle a list with duplicate elements"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"teal"},children:"Run completed in 220 milliseconds."}),"\n[info] ",(0,t.jsx)("span",{style:{color:"teal"},children:"Total number of tests run: 4"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"teal"},children:"Suites: completed 1, aborted 0"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"teal"},children:"Tests: succeeded 4, failed 0, canceled 0, ignored 0, pending 0"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"green"},children:"All tests passed."})]})}),"\n",(0,t.jsxs)(n.p,{children:["Suppose we used this modified definition of ",(0,t.jsx)(n.code,{children:"insert"}),", which does not retain duplicate elements:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"def insert(nums: List[Int], n: Int): List[Int] = {\n  nums match\n    case Nil => List(n)\n    case head :: tail =>\n      if n < head then\n        n :: nums\n      else if n == head then\n        nums\n      else\n        head :: insert(tail, n)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Then the output for the same test suite would change to:"}),"\n",(0,t.jsx)("pre",{children:(0,t.jsxs)(n.p,{children:["[info] ",(0,t.jsx)("span",{style:{color:"green"},children:"InsertionSortSpec:"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"green"},children:"Insertion Sort"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"green"},children:"- should sort a list of integers in ascending order"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"green"},children:"- should handle an empty list"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"green"},children:"- should handle a list with a single element"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"red"},children:"- should handle a list with duplicate elements *** FAILED ***"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"red"},children:"  List(1, 2, 3, 4, 5, 6, 9) did not equal List(1, 1, 2, 3, 4, 5, 5, 6, 9) (InsertionSortSpec.scala:23)"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"red"},children:"  Analysis:"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"red"},children:"  List(1: 2 -> 1, 2: 3 -> 2, 3: 4 -> 3, 4: 5 -> 4, 5: 6 -> 5, 6: 9 -> 5, 7: -> 6, 8: -> 9)"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"teal"},children:"Run completed in 246 milliseconds."}),"\n[info] ",(0,t.jsx)("span",{style:{color:"teal"},children:"Total number of tests run: 4"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"teal"},children:"Suites: completed 1, aborted 0"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"teal"},children:"Tests: succeeded 3, failed 1, canceled 0, ignored 0, pending 0"}),"\n[info] ",(0,t.jsx)("span",{style:{color:"red"},children:"*** 1 TEST FAILED ***"})]})}),"\n",(0,t.jsx)(n.h2,{id:"assertions",children:"Assertions"}),"\n",(0,t.jsxs)(n.p,{children:["As stated above, an assertion is a boolean expression that must be ",(0,t.jsx)(n.code,{children:"true"})," each time it is encountered\nduring program execution.\nFor example, in the ",(0,t.jsx)(n.a,{href:"/focsipedia2/docs/ds/lists",children:"Sorting Lists"})," section, the ",(0,t.jsx)(n.code,{children:"select"})," function used in selection\nsort requires that the input list be non-empty, and the ",(0,t.jsx)(n.code,{children:"insert"})," function used in insertion sort\nrequires that the input list be ordered.\nEach of these ",(0,t.jsx)(n.strong,{children:"preconditions"})," could be checked by an assertion (note that the original code\nonly had these preconditions in the form of comments; we are assuming here the existence of a\nfunction ",(0,t.jsx)(n.code,{children:"isSorted"})," that checks whether a list is in order):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"/* Precondition: nums is non-empty */\ndef select(nums: List[Int]): (Int, List[Int]) = {\n  // highlight-next-line\n  assert(!nums.isEmpty)\n  ...\n}\n\n/* Precondition: nums is sorted in non-decreasing order */\ndef insert(nums: List[Int], n: Int): List[Int] = {\n  // highlight-next-line\n  assert(isSorted(nums))\n  ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Instead of a precondition, which asserts a property of the input to a function, assertions\nare often used for ",(0,t.jsx)(n.strong,{children:"postconditions"})," and ",(0,t.jsx)(n.strong,{children:"invariants"}),".\nA postcondition asserts a claim about the output of a function; the combination of\npre- and post-conditions are often referred to as the ",(0,t.jsx)(n.strong,{children:"contract"})," of a function (just\nlike the signature of a function establishes a contract at the level of types).\nIn the sorting functions, one reasonable postcondition is that the output is in order.\nThis can be expressed in Scala by adding an ",(0,t.jsx)(n.code,{children:"ensuring"})," clause after the function body:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"def insertion_sort(nums: List[Int]): List[Int] = {\n  nums match\n    case Nil => Nil\n    case head :: tail => insert(insertion_sort(tail), head)\n} ensuring (result =>\n  isSorted(result)\n)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that the argument to ",(0,t.jsx)(n.code,{children:"ensuring"})," is an anonymous function value that will be applied to the\nresult of the preceding expression; our convention will be to use the parameter name\n",(0,t.jsx)(n.code,{children:"result"})," in this anonymous function, because it gives us a way to refer to the output of\nthe function by name."]}),"\n",(0,t.jsx)(n.p,{children:"An invariant asserts that a property is true each time an arbitrary point of the program is\nreached.\nThis is most commonly used in conjunction with loops and mutable variables; since a pure\nfunctional approach to Scala discourages such constructs, here is an example in Java:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"/** Compute a * b using only addition.\n * Precondition: b >= 0\n */\nstatic int times(int a, int b) {\n  assert b >= 0;\n  int result = 0;\n  for (int i = 0; i < b; i++) {\n    // highlight-next-line\n    assert result == a * i;\n    result += a;\n  }\n  assert result == a * b;\n  return result;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Each time we enter the loop, the invariant assures us that the current value of ",(0,t.jsx)(n.code,{children:"result"})," is\nthe same as ",(0,t.jsx)(n.code,{children:"a"})," times the current value of ",(0,t.jsx)(n.code,{children:"i"}),".\nSince the loop exits when ",(0,t.jsx)(n.code,{children:"i == b"}),", we can use this invariant to establish the desired\npostcondition that ",(0,t.jsx)(n.code,{children:"result"})," is ",(0,t.jsx)(n.code,{children:"a * b"}),".\nWhen we run this Java program with the ",(0,t.jsx)(n.code,{children:"-ea"}),' ("enable assertions") flag, it will check that\neach ',(0,t.jsx)(n.code,{children:"assert"})," line evaluates to ",(0,t.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["In Scala, if an assertion fails it will throw an error and halt the program with a\nmessage describing the failure.\nBecause of this abrupt reaction, and because the evaluation of assertions might take a significant\namount of the program's running time (consider how long it would take to check that ",(0,t.jsx)(n.code,{children:"nums"}),"\nis sorted on each call to ",(0,t.jsx)(n.code,{children:"insert"}),' while sorting a long list), it is common practice to only\n"turn on" assertion checking as part of the debugging process.\nBy passing an appropriate option to the Scala compiler, a release version of the program\ncan be generated where the ',(0,t.jsx)(n.code,{children:"assert"})," statements have been removed."]}),"\n",(0,t.jsx)(n.h2,{id:"property-testing",children:"Property Testing"}),"\n",(0,t.jsxs)(n.p,{children:["By combining testing with properties, we can have the best features of both.\n",(0,t.jsx)(n.strong,{children:"Property-based testing"})," lets us specify general properties that need to hold,\nbut instead of checking them at runtime with assertions (which we do ",(0,t.jsx)(n.strong,{children:"not"}),' want to\ndo in production) we test them in advance by running a tool that will generate a\nlarge number of "random" cases and checking each of the properties.\nIn effect, this automates the process of generating unit tests.']}),"\n",(0,t.jsxs)(n.p,{children:['The property testing tool knows the types of the data being tested, and can\ngenerate a suitable range of "arbitrary" values.\nA typical tool is ',(0,t.jsx)(n.a,{href:"https://scalacheck.org/",children:"ScalaCheck"}),", which has built-in\ngenerators for primitive types and standard collections; in addition to randomly\ngenerated values, it will also try common edge cases (such as ",(0,t.jsx)(n.code,{children:"Int.MaxValue"})," and\nthe empty list).\nFor custom data types, such as trees, it provides facilities to define new generators."]}),"\n",(0,t.jsxs)(n.p,{children:["Here is an example of some properties written in ScalaCheck that will test the\nbehavior of our insertion sort function.\nThese properties are written in the form ",(0,t.jsx)(n.code,{children:"forAll {(a: T) => P(a)}"}),", which is the\nsignal to ScalaCheck that it should generate arbitrary values ",(0,t.jsx)(n.code,{children:"a"})," of type ",(0,t.jsx)(n.code,{children:"T"}),"\n(by default, it generates 100 of them), and check whether the boolean expression\n",(0,t.jsx)(n.code,{children:"P(a)"})," is ",(0,t.jsx)(n.code,{children:"true"}),".",(0,t.jsx)(n.sup,{children:(0,t.jsx)(n.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'object InsertionSortPropSpec extends Properties("Insertion Sort") {\n  import Prop.forAll\n\n  property("same length") = forAll { (a: List[Int]) =>\n    a.length == insertion_sort(a).length\n  }\n\n  property("sorted") = forAll { (a: List[Int]) =>\n    isSorted(insertion_sort(a))\n  }\n\n  property("same elements") = forAll { (a: List[Int]) =>\n    val aSorted = insertion_sort(a)\n    a.forall(x => aSorted contains x) && aSorted.forall(x => a contains x)\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"When run with ScalaCheck, the output from this will be"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"+ Insertion Sort.same length: OK, passed 100 tests.\n+ Insertion Sort.sorted: OK, passed 100 tests.\n+ Insertion Sort.same elements: OK, passed 100 tests.\n"})}),"\n",(0,t.jsx)(n.p,{children:"If we run it on the faulty version of insertion sort that discards duplicates, the output\nmight instead be"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'! Insertion Sort.same length: Falsified after 5 passed tests.\n> ARG_0: List("0", "0")\n> ARG_0_ORIGINAL: List("0", "2147483647", "-30181727", "0")\n+ Insertion Sort.sorted: OK, passed 100 tests.\n+ Insertion Sort.same elements: OK, passed 100 tests.\nFound 1 failing properties.\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Note that it first found a failing input: ",(0,t.jsx)(n.code,{children:"List(0, 2147483647, -30181727, 0)"}),".\nA common ability of property-based testers is that once a failing case is found,\nit will then attempt to generate simpler related cases until it finds a\nminimal counterexample.\nIn this run, ScalaCheck was able to shrink the failing case down to ",(0,t.jsx)(n.code,{children:"List(0, 0)"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"correctness-proofs",children:"Correctness Proofs"}),"\n",(0,t.jsx)(n.p,{children:"In some cases it is possible to go further than just checking that properties hold for\na sampling of values.\nIf we can construct a logical proof which establishes that the desired postcondition\nfollows from the precondition and the body of each function, then we will have an\nabsolute guarantee that the code satisfies its specification."}),"\n",(0,t.jsxs)(n.p,{children:["The compositional nature of functional programming really shines here, because it is\n",(0,t.jsx)(n.em,{children:"much"})," easier to complete this sort of formal correctness proof when working with\npure functions, where we do not have to worry about tracking the current state of mutable variables.\nWith that said, all is not lost for imperative code, but we will need more powerful techniques\n(see for example ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Hoare_logic",children:"Hoare Logic"}),") to reason about state."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://epfl-lara.github.io/stainless/",children:"Stainless"})," framework is one tool (another is\n",(0,t.jsx)(n.a,{href:"https://logika.sireum.org/",children:"Sireum Logika"}),") for verifying the behavior of Scala programs.\nIt works by extracting ",(0,t.jsx)(n.strong,{children:"verification conditions"})," (VCs) from a (subset of) Scala program that has\nbeen augmented with pre- and postconditions as we saw in the ",(0,t.jsx)(n.a,{href:"#assertions",children:"Assertions"})," section\n(except for technical reasons we use ",(0,t.jsx)(n.code,{children:"require"})," instead of ",(0,t.jsx)(n.code,{children:"assert"})," for the precondition).\nStainless also generates VCs for Scala features such as pattern matching, to ensure that there\nare cases to cover all of the possible values; it also generates conditions that assert that\nthe program will terminate and not loop forever\u2014this is a stronger statement: not only will\nit not produce an incorrect result, it will actually produce a correct result!\nIt then hands these VCs over to an automated theorem prover (by default, the\n",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Z3_Theorem_Prover",children:"Z3"})," prover from Microsoft) and attempts to\nfind a proof using techniques such as ",(0,t.jsx)(n.a,{href:"/focsipedia2/docs/logic/induction",children:"induction"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Here is an example of our insertion sort code with appropriate pre- and postconditions\n(the code is slightly different, mostly around the pattern-matching on lists, because\nStainless relies on its own library of basic data types which already have a large number\nof useful properties established):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"def insert(nums: List[Int], n: Int): List[Int] = {\n  require(isSorted(nums))\n\n  nums match \n    case Nil() => List(n)\n    case Cons(head, tail) =>\n      if n <= head then\n        n :: nums\n      else\n        head :: insert(tail, n)\n} ensuring (result =>\n  isSorted(result) &&\n  result.content == nums.content + n &&\n  result.size == nums.size + 1\n)\n\ndef insertion_sort(nums: List[Int]): List[Int] = {\n  nums match \n    case Nil() => Nil()\n    case Cons(head, tail) => insert(insertion_sort(tail), head)\n} ensuring (result =>\n  isSorted(result) &&\n  result.content == nums.content &&\n  result.size == nums.size\n)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Running this through Stainless leads to sucessfully generating proofs of 17 verification conditions,\nestablishing that the code will correctly sort any possible list of ints."}),"\n",(0,t.jsx)("pre",{children:(0,t.jsxs)(n.p,{children:["[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"]   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2554\u2550\u2561 ",(0,t.jsx)("span",{style:{color:"green"},children:"stainless summary"})," \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                                                                                 \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:10:7: "}),"   ",(0,t.jsx)("span",{style:{color:"green"},children:"insert"}),"          ",(0,t.jsx)("span",{style:{color:"green"},children:"non-negative measure"}),"                                      ",(0,t.jsx)("span",{style:{color:"green"},children:"valid"}),"             ",(0,t.jsxs)("span",{style:{color:"green"},children:["U",":smt-z3"]}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"0.1"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:13:5: "}),"   ",(0,t.jsx)("span",{style:{color:"green"},children:"insert"}),"          ",(0,t.jsx)("span",{style:{color:"green"},children:"body assertion: match exhaustiveness"}),"                      ",(0,t.jsx)("span",{style:{color:"green"},children:"valid"}),"             ",(0,t.jsxs)("span",{style:{color:"green"},children:["U",":smt-z3"]}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"0.0"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:13:5: "}),"   ",(0,t.jsx)("span",{style:{color:"green"},children:"insert"}),"          ",(0,t.jsx)("span",{style:{color:"green"},children:"postcondition"}),"                                             ",(0,t.jsx)("span",{style:{color:"green"},children:"valid from cache"}),"  ",(0,t.jsx)("span",{style:{color:"green"}}),"          ",(0,t.jsx)("span",{style:{color:"green"},children:"0.0"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:14:26: "}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"insert"}),"          ",(0,t.jsx)("span",{style:{color:"green"},children:"postcondition"}),"                                             ",(0,t.jsx)("span",{style:{color:"green"},children:"valid"}),"             ",(0,t.jsxs)("span",{style:{color:"green"},children:["U",":smt-z3"]}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"0.1"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:17:11: "}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"insert"}),"          ",(0,t.jsx)("span",{style:{color:"green"},children:"postcondition"}),"                                             ",(0,t.jsx)("span",{style:{color:"green"},children:"valid"}),"             ",(0,t.jsxs)("span",{style:{color:"green"},children:["U",":smt-z3"]}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"0.1"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:19:11: "}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"insert"}),"          ",(0,t.jsx)("span",{style:{color:"green"},children:"postcondition"}),"                                             ",(0,t.jsx)("span",{style:{color:"green"},children:"valid"}),"             ",(0,t.jsxs)("span",{style:{color:"green"},children:["U",":smt-z3"]}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"0.2"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:19:19: "}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"insert"}),"          ",(0,t.jsx)("span",{style:{color:"green"},children:"measure decreases"}),"                                         ",(0,t.jsx)("span",{style:{color:"green"},children:"valid"}),"             ",(0,t.jsxs)("span",{style:{color:"green"},children:["U",":smt-z3"]}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"0.1"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:19:19: "}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"insert"}),"          ",(0,t.jsx)("span",{style:{color:"green"},children:"precond. (call insert((scrut.t): @DropVCs , n))"}),"           ",(0,t.jsx)("span",{style:{color:"green"},children:"valid"}),"             ",(0,t.jsxs)("span",{style:{color:"green"},children:["U",":smt-z3"]}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"0.0"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:26:7: "}),"   ",(0,t.jsx)("span",{style:{color:"green"},children:"insertion_sort"}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"non-negative measure"}),"                                      ",(0,t.jsx)("span",{style:{color:"green"},children:"valid"}),"             ",(0,t.jsxs)("span",{style:{color:"green"},children:["U",":smt-z3"]}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"0.0"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:27:5: "}),"   ",(0,t.jsx)("span",{style:{color:"green"},children:"insertion_sort"}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"body assertion: match exhaustiveness"}),"                      ",(0,t.jsx)("span",{style:{color:"green"},children:"trivial"}),"           ",(0,t.jsx)("span",{style:{color:"green"}}),"          ",(0,t.jsx)("span",{style:{color:"green"},children:"0.0"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:27:5: "}),"   ",(0,t.jsx)("span",{style:{color:"green"},children:"insertion_sort"}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"postcondition"}),"                                             ",(0,t.jsx)("span",{style:{color:"green"},children:"trivial"}),"           ",(0,t.jsx)("span",{style:{color:"green"}}),"          ",(0,t.jsx)("span",{style:{color:"green"},children:"0.0"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:28:21: "}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"insertion_sort"}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"postcondition"}),"                                             ",(0,t.jsx)("span",{style:{color:"green"},children:"valid"}),"             ",(0,t.jsxs)("span",{style:{color:"green"},children:["U",":smt-z3"]}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"0.1"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:29:32: "}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"insertion_sort"}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"postcondition"}),"                                             ",(0,t.jsx)("span",{style:{color:"green"},children:"valid"}),"             ",(0,t.jsxs)("span",{style:{color:"green"},children:["U",":smt-z3"]}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"0.2"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:29:32: "}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"insertion_sort"}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"precond. (call insert(insertion_sort((scrut.t): @Dro...)"}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"valid"}),"             ",(0,t.jsxs)("span",{style:{color:"green"},children:["U",":smt-z3"]}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"0.3"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:29:39: "}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"insertion_sort"}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"measure decreases"}),"                                         ",(0,t.jsx)("span",{style:{color:"green"},children:"valid"}),"             ",(0,t.jsxs)("span",{style:{color:"green"},children:["U",":smt-z3"]}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"0.1"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:5:7: "}),"    ",(0,t.jsx)("span",{style:{color:"green"},children:"isSorted"}),"        ",(0,t.jsx)("span",{style:{color:"green"},children:"non-negative measure"}),"                                      ",(0,t.jsx)("span",{style:{color:"green"},children:"valid from cache"}),"  ",(0,t.jsx)("span",{style:{color:"green"}}),"          ",(0,t.jsx)("span",{style:{color:"green"},children:"0.0"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"src/main/scala/InsertionSort.scala:6:48: "}),"   ",(0,t.jsx)("span",{style:{color:"green"},children:"isSorted"}),"        ",(0,t.jsx)("span",{style:{color:"green"},children:"measure decreases"}),"                                         ",(0,t.jsx)("span",{style:{color:"green"},children:"valid"}),"             ",(0,t.jsxs)("span",{style:{color:"green"},children:["U",":smt-z3"]}),"  ",(0,t.jsx)("span",{style:{color:"green"},children:"0.0"})," \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u255f\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u2562\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u2551 ",(0,t.jsx)("span",{style:{color:"green"},children:"total: 17   valid: 17   (2 from cache, 2 trivial) invalid: 0    unknown: 0    time:    1.26"}),"                                                           \u2551\n[",(0,t.jsx)("span",{style:{color:"blue"},children:"  Info  "}),"] \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d"]})}),"\n",(0,t.jsx)(n.p,{children:"We are still limited by the detail of our specification.\nFor example, we have not specified anything here about the running time or stack depth needed for this code;\nindeed, we know that this particular example will crash with a stack overflow if the list is too long,\nbecause it is not written in tail-recursive style."}),"\n",(0,t.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsx)(n.p,{children:"TBD"}),"\n","\n",(0,t.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,t.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{id:"user-content-fn-1",children:["\n",(0,t.jsxs)(n.p,{children:["Note that the ScalaCheck ",(0,t.jsx)(n.code,{children:"forAll"})," function is different from the method\n",(0,t.jsx)(n.code,{children:"forall"}),' defined on lists in Scala (and used in the "same elements" property),\nwhich maps a predicate over all of the elements of the given list and then\n"ands" the results together. ',(0,t.jsx)(n.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>a});var t=s(6540);const r={},o=t.createContext(r);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);