"use strict";(self.webpackChunkfocsipedia=self.webpackChunkfocsipedia||[]).push([[1829],{73779:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"mySidebar":[{"type":"category","label":"Course Info","items":[{"type":"link","href":"/focsipedia2/docs/attribution","label":"Attribution","docId":"attribution","unlisted":false},{"type":"link","href":"/focsipedia2/docs/policies","label":"Course Information and Policies","docId":"policies","unlisted":false},{"type":"link","href":"/focsipedia2/docs/236topics","label":"CSC 236 Topics","docId":"236topics","unlisted":false},{"type":"link","href":"/focsipedia2/docs/algoverview","label":"Overview of Algorithmic Foundations","docId":"algoverview","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Logic","items":[{"type":"link","href":"/focsipedia2/docs/logic/intro","label":"Logic","docId":"logic/intro","unlisted":false},{"type":"link","href":"/focsipedia2/docs/logic/props","label":"Propositional Logic","docId":"logic/props","unlisted":false},{"type":"link","href":"/focsipedia2/docs/logic/boolean","label":"Boolean Algebra","docId":"logic/boolean","unlisted":false},{"type":"link","href":"/focsipedia2/docs/logic/circuits","label":"Logic Circuits","docId":"logic/circuits","unlisted":false},{"type":"link","href":"/focsipedia2/docs/logic/simplify","label":"Circuit Simplification","docId":"logic/simplify","unlisted":false},{"type":"link","href":"/focsipedia2/docs/logic/components","label":"Common Circuit Components","docId":"logic/components","unlisted":false},{"type":"link","href":"/focsipedia2/docs/logic/preds","label":"Predicates and Quantifiers","docId":"logic/preds","unlisted":false},{"type":"link","href":"/focsipedia2/docs/logic/deduction","label":"Deduction","docId":"logic/deduction","unlisted":false},{"type":"link","href":"/focsipedia2/docs/logic/pred-deduction","label":"Natural Deduction for Predicate Logic","docId":"logic/pred-deduction","unlisted":false},{"type":"link","href":"/focsipedia2/docs/logic/recind","label":"Recursion and Induction","docId":"logic/recind","unlisted":false},{"type":"link","href":"/focsipedia2/docs/logic/sequential","label":"Sequential Circuits","docId":"logic/sequential","unlisted":false},{"type":"link","href":"/focsipedia2/docs/logic/state","label":"State Machines","docId":"logic/state","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Sets","items":[{"type":"link","href":"/focsipedia2/docs/sets/concepts","label":"Set Concepts","docId":"sets/concepts","unlisted":false},{"type":"link","href":"/focsipedia2/docs/sets/algebra","label":"Boolean Algebra of Sets","docId":"sets/algebra","unlisted":false},{"type":"link","href":"/focsipedia2/docs/sets/programming","label":"Programming with Sets","docId":"sets/programming","unlisted":false},{"type":"link","href":"/focsipedia2/docs/sets/functions","label":"Functions","docId":"sets/functions","unlisted":false},{"type":"link","href":"/focsipedia2/docs/sets/relations","label":"Relations","docId":"sets/relations","unlisted":false},{"type":"link","href":"/focsipedia2/docs/sets/database","label":"Relational Databases","docId":"sets/database","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Functional Programming","items":[{"type":"link","href":"/focsipedia2/docs/fp/intro","label":"Introduction to Functional Programming","docId":"fp/intro","unlisted":false},{"type":"link","href":"/focsipedia2/docs/fp/types","label":"Types in Functional Programming","docId":"fp/types","unlisted":false},{"type":"link","href":"/focsipedia2/docs/fp/map-reduce","label":"Map and Reduce on Lists","docId":"fp/map-reduce","unlisted":false},{"type":"link","href":"/focsipedia2/docs/fp/doodle","label":"Doodle Graphics","docId":"fp/doodle","unlisted":false},{"type":"link","href":"/focsipedia2/docs/fp/state","label":"State Machines in Java and Scala","docId":"fp/state","unlisted":false},{"type":"link","href":"/focsipedia2/docs/fp/parser-comb","label":"Recursive Descent and Parser Combinators","docId":"fp/parser-comb","unlisted":false},{"type":"link","href":"/focsipedia2/docs/fp/lambda","label":"Lambda Calculus","docId":"fp/lambda","unlisted":false},{"type":"link","href":"/focsipedia2/docs/fp/recursive","label":"General Recursive Functions","docId":"fp/recursive","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Lists, Trees, and Graphs","items":[{"type":"link","href":"/focsipedia2/docs/ds/lists","label":"Sorting Lists","docId":"ds/lists","unlisted":false},{"type":"link","href":"/focsipedia2/docs/ds/recurrence","label":"Running Time and Recurrences","docId":"ds/recurrence","unlisted":false},{"type":"link","href":"/focsipedia2/docs/ds/verification","label":"Program Verification","docId":"ds/verification","unlisted":false},{"type":"link","href":"/focsipedia2/docs/ds/trees","label":"Trees","docId":"ds/trees","unlisted":false},{"type":"link","href":"/focsipedia2/docs/ds/bst","label":"Binary Search Trees and Heaps","docId":"ds/bst","unlisted":false},{"type":"link","href":"/focsipedia2/docs/ds/balance","label":"Balanced Binary Search Trees","docId":"ds/balance","unlisted":false},{"type":"link","href":"/focsipedia2/docs/ds/graphs","label":"Graphs","docId":"ds/graphs","unlisted":false},{"type":"link","href":"/focsipedia2/docs/ds/components","label":"Connected Components","docId":"ds/components","unlisted":false},{"type":"link","href":"/focsipedia2/docs/ds/paths","label":"Shortest Paths and Minimum Spanning Trees","docId":"ds/paths","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Algorithms","items":[{"type":"link","href":"/focsipedia2/docs/ds/decrease","label":"Decrease-and-Conquer Strategy","docId":"ds/decrease","unlisted":false},{"type":"link","href":"/focsipedia2/docs/ds/divide","label":"Divide-and-Conquer Strategy","docId":"ds/divide","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Formal Languages","items":[{"type":"link","href":"/focsipedia2/docs/lang/languages","label":"Languages","docId":"lang/languages","unlisted":false},{"type":"link","href":"/focsipedia2/docs/lang/regexp","label":"Regular Expressions","docId":"lang/regexp","unlisted":false},{"type":"link","href":"/focsipedia2/docs/lang/regexpapp","label":"Applications of Regular Expressions","docId":"lang/regexpapp","unlisted":false},{"type":"link","href":"/focsipedia2/docs/lang/fsa","label":"Finite-State Automata","docId":"lang/fsa","unlisted":false},{"type":"link","href":"/focsipedia2/docs/lang/nfa","label":"Nondeterministic Finite-State Automata","docId":"lang/nfa","unlisted":false},{"type":"link","href":"/focsipedia2/docs/lang/fsareg","label":"Finite-State Automata and Regular Languages","docId":"lang/fsareg","unlisted":false},{"type":"link","href":"/focsipedia2/docs/lang/cfg","label":"Context-Free Grammars","docId":"lang/cfg","unlisted":false},{"type":"link","href":"/focsipedia2/docs/lang/bnf","label":"Backus-Naur Form","docId":"lang/bnf","unlisted":false},{"type":"link","href":"/focsipedia2/docs/lang/parsing","label":"Parsing and Parse Trees","docId":"lang/parsing","unlisted":false},{"type":"link","href":"/focsipedia2/docs/lang/pda","label":"Pushdown Automata","docId":"lang/pda","unlisted":false},{"type":"link","href":"/focsipedia2/docs/lang/tm","label":"General Grammars and Turing Machines","docId":"lang/tm","unlisted":false},{"type":"link","href":"/focsipedia2/docs/lang/computability","label":"Computability","docId":"lang/computability","unlisted":false},{"type":"link","href":"/focsipedia2/docs/lang/halting","label":"The Halting Problem","docId":"lang/halting","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Features","items":[{"type":"link","href":"/focsipedia2/docs/scala","label":"Scala","docId":"scala","unlisted":false},{"type":"link","href":"/focsipedia2/docs/styleGuide","label":"Style Guide","docId":"styleGuide","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Supplementary Topics","items":[{"type":"link","href":"/focsipedia2/docs/reason","label":"ReasonML","docId":"reason","unlisted":false},{"type":"link","href":"/focsipedia2/docs/ocaml","label":"OCaml","docId":"ocaml","unlisted":false},{"type":"link","href":"/focsipedia2/docs/233topics","label":"CSC 233 Topics","docId":"233topics","unlisted":false},{"type":"link","href":"/focsipedia2/docs/overview","label":"Overview of Foundations","docId":"overview","unlisted":false},{"type":"link","href":"/focsipedia2/docs/fp/overview","label":"Overview of Functional Programming","docId":"fp/overview","unlisted":false},{"type":"link","href":"/focsipedia2/docs/methods","label":"Methods in Scala","docId":"methods","unlisted":false},{"type":"link","href":"/focsipedia2/docs/fp/curry","label":"Currying","docId":"fp/curry","unlisted":false},{"type":"link","href":"/focsipedia2/docs/fp/natded","label":"Functional Programming and Natural Deduction","docId":"fp/natded","unlisted":false}],"collapsed":true,"collapsible":true}]},"docs":{"233topics":{"id":"233topics","title":"CSC 233 Topics","description":"This page gives the order of topics as they are covered in the DePauw course CSC 233, Foundations of Computation.","sidebar":"mySidebar"},"236topics":{"id":"236topics","title":"CSC 236 Topics","description":"This page gives the order of topics as they are covered in the DePauw course CSC 236, Algorithmic Foundations of Computation.","sidebar":"mySidebar"},"algoverview":{"id":"algoverview","title":"Overview of Algorithmic Foundations","description":"The Foundations of Computer Science come from mathematics, although they are not limited to the sorts of mathematics conventionally studied in elementary and secondary schools.","sidebar":"mySidebar"},"attribution":{"id":"attribution","title":"Attribution","description":"This work is dedicated to my wife, Eleanor, who hopes that one day it will grow up and","sidebar":"mySidebar"},"ds/balance":{"id":"ds/balance","title":"Balanced Binary Search Trees","description":"As we saw in the previous section, the height of a binary tree with $N$ nodes","sidebar":"mySidebar"},"ds/bst":{"id":"ds/bst","title":"Binary Search Trees and Heaps","description":"Let us consider binary trees whose values can be ordered.","sidebar":"mySidebar"},"ds/components":{"id":"ds/components","title":"Connected Components","description":"Undirected Graphs","sidebar":"mySidebar"},"ds/decrease":{"id":"ds/decrease","title":"Decrease-and-Conquer Strategy","description":"We have already seen several examples of the decrease-and-conquer strategy of algorithm design.","sidebar":"mySidebar"},"ds/divide":{"id":"ds/divide","title":"Divide-and-Conquer Strategy","description":"TODO","sidebar":"mySidebar"},"ds/graphs":{"id":"ds/graphs","title":"Graphs","description":"Graph Terminology","sidebar":"mySidebar"},"ds/lists":{"id":"ds/lists","title":"Sorting Lists","description":"We have already seen how to work with lists in a functional language.","sidebar":"mySidebar"},"ds/paths":{"id":"ds/paths","title":"Shortest Paths and Minimum Spanning Trees","description":"Dijkstra\'s Algorithm","sidebar":"mySidebar"},"ds/recurrence":{"id":"ds/recurrence","title":"Running Time and Recurrences","description":"Basics of Big-Oh Notation","sidebar":"mySidebar"},"ds/trees":{"id":"ds/trees","title":"Trees","description":"Binary Trees","sidebar":"mySidebar"},"ds/verification":{"id":"ds/verification","title":"Program Verification","description":"How do you know that a program is correct?","sidebar":"mySidebar"},"fp/curry":{"id":"fp/curry","title":"Currying","description":"When we write a function that takes multiple arguments, we may list the parameters","sidebar":"mySidebar"},"fp/doodle":{"id":"fp/doodle","title":"Doodle Graphics","description":"Doodle","sidebar":"mySidebar"},"fp/doodle-project":{"id":"fp/doodle-project","title":"Doodle Graphics Drawing Project","description":"Create a drawing using the Doodle graphics library. You should feel free to be as creative as you like, the only requirement is that the drawing use recursion in an essential way."},"fp/galleryS20A":{"id":"fp/galleryS20A","title":"Spring 2020 DPoodle Gallery, Section A","description":"Allyson Low"},"fp/galleryS20B":{"id":"fp/galleryS20B","title":"Spring 2020 DPoodle Gallery, Section B","description":"Alecia Hawkins"},"fp/intro":{"id":"fp/intro","title":"Introduction to Functional Programming","description":"(Content adapted from Critchlow & Eck)","sidebar":"mySidebar"},"fp/lambda":{"id":"fp/lambda","title":"Lambda Calculus","description":"The section on computability mentioned the Church-Turing Thesis that Turing machines","sidebar":"mySidebar"},"fp/map-reduce":{"id":"fp/map-reduce","title":"Map and Reduce on Lists","description":"Two of the most fundamental operations on lists are map and reduce.","sidebar":"mySidebar"},"fp/natded":{"id":"fp/natded","title":"Functional Programming and Natural Deduction","description":"Finally, here is the \\"big reveal\\" about natural deduction. The proofs that we","sidebar":"mySidebar"},"fp/overview":{"id":"fp/overview","title":"Overview of Functional Programming","description":"There is a more extensive introduction to FP later, but this section provides an early introduction to some of the concepts and tools that we will be using throughout the course.","sidebar":"mySidebar"},"fp/parser-comb":{"id":"fp/parser-comb","title":"Recursive Descent and Parser Combinators","description":"It is particularly easy to turn an LL(1) grammar into an efficient parser","sidebar":"mySidebar"},"fp/recursive":{"id":"fp/recursive","title":"General Recursive Functions","description":"So far, when talking about computability, we have been concerned with the question of deciding membership of a string in a language.","sidebar":"mySidebar"},"fp/scaladoodle":{"id":"fp/scaladoodle","title":"Scala Doodle","description":"This is the code for the DePauw Scala version of the Doodle library (as used on scalafiddle.io):"},"fp/state":{"id":"fp/state","title":"State Machines in Java and Scala","description":"There are many ways to implement the state machine concept in code. The essence is that","sidebar":"mySidebar"},"fp/types":{"id":"fp/types","title":"Types in Functional Programming","description":"One of the hallmarks of modern functional programming is a strong and rich","sidebar":"mySidebar"},"greeting":{"id":"greeting","title":"Hello","description":"Hello from Docusaurus"},"lang/bnf":{"id":"lang/bnf","title":"Backus-Naur Form","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"lang/cfg":{"id":"lang/cfg","title":"Context-Free Grammars","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"lang/computability":{"id":"lang/computability","title":"Computability","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"lang/fsa":{"id":"lang/fsa","title":"Finite-State Automata","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"lang/fsareg":{"id":"lang/fsareg","title":"Finite-State Automata and Regular Languages","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"lang/halting":{"id":"lang/halting","title":"The Halting Problem","description":"As suggested in the previous section, there is an important distinction between a language being recursive and being recursively enumerable.","sidebar":"mySidebar"},"lang/languages":{"id":"lang/languages","title":"Languages","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"lang/nfa":{"id":"lang/nfa","title":"Nondeterministic Finite-State Automata","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"lang/parsing":{"id":"lang/parsing","title":"Parsing and Parse Trees","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"lang/pda":{"id":"lang/pda","title":"Pushdown Automata","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"lang/regexp":{"id":"lang/regexp","title":"Regular Expressions","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"lang/regexpapp":{"id":"lang/regexpapp","title":"Applications of Regular Expressions","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"lang/tm":{"id":"lang/tm","title":"General Grammars and Turing Machines","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"logic/boolean":{"id":"logic/boolean","title":"Boolean Algebra","description":"(Content adapted from Critchlow & Eck)","sidebar":"mySidebar"},"logic/circuits":{"id":"logic/circuits","title":"Logic Circuits","description":"(Content adapted from Critchlow & Eck)","sidebar":"mySidebar"},"logic/components":{"id":"logic/components","title":"Common Circuit Components","description":"Just as a complicated piece of software is never written from scratch entirely","sidebar":"mySidebar"},"logic/deduction":{"id":"logic/deduction","title":"Deduction","description":"(Content adapted from Critchlow & Eck)","sidebar":"mySidebar"},"logic/induction":{"id":"logic/induction","title":"Mathematical Induction","description":"(Content adapted from Critchlow & Eck)"},"logic/intro":{"id":"logic/intro","title":"Logic","description":"(Adapted from Critchlow & Eck)","sidebar":"mySidebar"},"logic/pred-deduction":{"id":"logic/pred-deduction","title":"Natural Deduction for Predicate Logic","description":"Before seeing the natural deduction rules for handling the quantifiers","sidebar":"mySidebar"},"logic/preds":{"id":"logic/preds","title":"Predicates and Quantifiers","description":"(Content adapted from Critchlow & Eck)","sidebar":"mySidebar"},"logic/props":{"id":"logic/props","title":"Propositional Logic","description":"(Content adapted from Critchlow & Eck)","sidebar":"mySidebar"},"logic/recind":{"id":"logic/recind","title":"Recursion and Induction","description":"(Some content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"logic/recursion":{"id":"logic/recursion","title":"Recursion and Induction","description":"(Content adapted from Critchlow & Eck)"},"logic/sequential":{"id":"logic/sequential","title":"Sequential Circuits","description":"All of the circuits we have considered so far have been acyclic; this was an essential part of the definition of a combinational circuit.","sidebar":"mySidebar"},"logic/simplify":{"id":"logic/simplify","title":"Circuit Simplification","description":"(Content adapted from Critchlow & Eck)","sidebar":"mySidebar"},"logic/state":{"id":"logic/state","title":"State Machines","description":"In another section we learned about Moore machines, a version of finite state automata where there is an output associated with each state.","sidebar":"mySidebar"},"methods":{"id":"methods","title":"Methods in Scala","description":"You may be wondering why the section on functions in Java and Scala","sidebar":"mySidebar"},"ocaml":{"id":"ocaml","title":"OCaml","description":"OCaml is a functional programming language developed at Inria over the past thirty years.","sidebar":"mySidebar"},"overview":{"id":"overview","title":"Overview of Foundations","description":"The Foundations of Computer Science come from mathematics, although they are not limited to the sorts of mathematics conventionally studied in elementary and secondary schools.","sidebar":"mySidebar"},"policies":{"id":"policies","title":"Course Information and Policies","description":"What, Where, When, Who, ...","sidebar":"mySidebar"},"reason":{"id":"reason","title":"ReasonML","description":"ReasonML (often just called Reason) is a functional","sidebar":"mySidebar"},"scala":{"id":"scala","title":"Scala","description":"Scala is a multi-paradigm programming language that","sidebar":"mySidebar"},"sets/algebra":{"id":"sets/algebra","title":"Boolean Algebra of Sets","description":"(Content adapted from Critchlow & Eck)","sidebar":"mySidebar"},"sets/concepts":{"id":"sets/concepts","title":"Set Concepts","description":"(Content adapted from Critchlow & Eck)","sidebar":"mySidebar"},"sets/database":{"id":"sets/database","title":"Relational Databases","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"sets/functions":{"id":"sets/functions","title":"Functions","description":"(Content adapted from Critchlow & Eck)","sidebar":"mySidebar"},"sets/programming":{"id":"sets/programming","title":"Programming with Sets","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"sets/relations":{"id":"sets/relations","title":"Relations","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"mySidebar"},"styleGuide":{"id":"styleGuide","title":"Style Guide","description":"You can write content using GitHub-flavored Markdown syntax.","sidebar":"mySidebar"}}}}')}}]);